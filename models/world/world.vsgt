#vsga 0.1.2
Root id=1 vsg::MatrixTransform
{
  NumUserObjects 0
  NumChildren 1
  Child id=2 vsg::StateGroup
  {
    NumUserObjects 0
    NumChildren 1
    Child id=3 vsg::MatrixTransform
    {
      NumUserObjects 0
      NumChildren 8
      Child id=4 vsg::MatrixTransform
      {
        NumUserObjects 0
        NumChildren 1
        Child id=5 vsg::StateGroup
        {
          NumUserObjects 0
          NumChildren 1
          Child id=6 vsg::VertexIndexDraw
          {
            NumUserObjects 0
            firstBinding 0
            NumArrays 3
            Array id=7 vsg::vec3Array
            {
              NumUserObjects 0
              Layout 0 12 0 1 1 1 0 -1
              Size 679
              Storage id=0
              Data 4.43 0.336 0 4.201 0.336 0 4.201 0.248 0 4.332 0.248 0
               4.332 0.108 0 4.32023 0.104318 0 4.3084 0.100792 0 4.2965 0.0974531 0
               4.28452 0.0943333 0 4.27244 0.0914636 0 4.26025 0.088875 0 4.24794 0.086599 0
               4.23548 0.0846667 0 4.22288 0.0831094 0 4.2101 0.0819583 0 4.19715 0.0812448 0
               4.184 0.081 0 4.184 0.081 0 4.14454 0.0831933 0 4.10731 0.0896296 0
               4.10731 0.0896296 0 4.07253 0.100094 0 4.04044 0.11437 0 4.04044 0.11437 0
               4.01127 0.132244 0 4.01127 0.132244 0 3.98525 0.1535 0 3.98525 0.1535 0
               3.9626 0.177922 0 3.9626 0.177922 0 3.94356 0.205296 0 3.92834 0.235406 0
               3.91719 0.268037 0 3.91719 0.268037 0 3.91034 0.302973 0 3.908 0.34 0
               3.908 0.34 0 3.91035 0.376226 0 3.91035 0.376226 0 3.9172 0.410722 0
               3.92828 0.443219 0 3.9433 0.473444 0 3.9433 0.473444 0 3.96196 0.501129 0
               3.96196 0.501129 0 3.984 0.526 0 4.00912 0.547788 0 4.03704 0.566222 0
               4.06747 0.581031 0 4.10013 0.591945 0 4.13474 0.598691 0 4.13474 0.598691 0
               4.171 0.601 0 4.171 0.601 0 4.19152 0.600522 0 4.21207 0.599093 0
               4.21207 0.599093 0 4.23263 0.596719 0 4.25319 0.593407 0 4.27373 0.589166 0
               4.29425 0.584 0 4.31473 0.577918 0 4.33515 0.570926 0 4.3555 0.563031 0
               4.37577 0.554241 0 4.37577 0.554241 0 4.39594 0.544561 0 4.39594 0.544561 0
               4.416 0.534 0 4.416 0.633 0 4.416 0.633 0 4.39027 0.643594 0
               4.3664 0.652921 0 4.34414 0.661047 0 4.32322 0.668037 0 4.30339 0.673958 0
               4.28438 0.678875 0 4.26593 0.682855 0 4.24778 0.685963 0 4.22967 0.688266 0
               4.21135 0.689829 0 4.19254 0.690718 0 4.173 0.691 0 4.1221 0.687873 0
               4.07367 0.678736 0 4.02806 0.663953 0 3.98567 0.643889 0 3.94685 0.618908 0
               3.94685 0.618908 0 3.912 0.589375 0 3.912 0.589375 0 3.88148 0.555655 0
               3.85567 0.518111 0 3.83494 0.477109 0 3.83494 0.477109 0 3.81967 0.433014 0
               3.81023 0.386189 0 3.81023 0.386189 0 3.807 0.337 0 3.807 0.337 0
               3.81015 0.288178 0 3.81015 0.288178 0 3.81938 0.241926 0 3.81938 0.241926 0
               3.83433 0.198563 0 3.85467 0.158407 0 3.85467 0.158407 0 3.88005 0.12178 0
               3.88005 0.12178 0 3.91013 0.0890001 0 3.91013 0.0890001 0 3.94456 0.0603866 0
               3.94456 0.0603866 0 3.983 0.0362593 0 4.02511 0.0169376 0 4.07054 0.00274082 0
               4.07054 0.00274082 0 4.11895 -0.00601149 0 4.11895 -0.00601149 0 4.17 -0.009 0
               4.17 -0.009 0 4.19333 -0.00866204 0 4.21593 -0.00762963 0 4.21593 -0.00762963 0
               4.23791 -0.005875 0 4.25941 -0.00337037 0 4.28056 -8.79632e-05 0 4.28056 -8.79632e-05 0
               4.3015 0.004 0 4.32236 0.0089213 0 4.34326 0.0147037 0 4.36434 0.021375 0
               4.38574 0.028963 0 4.40758 0.0374954 0 4.43 0.047 0 3.698 0.643 0
               3.68592 0.650667 0 3.67369 0.657667 0 3.66131 0.664 0 3.64882 0.669667 0
               3.63621 0.674667 0 3.63621 0.674667 0 3.6235 0.679 0 3.61071 0.682667 0
               3.59785 0.685667 0 3.58494 0.688 0 3.58494 0.688 0 3.57198 0.689667 0
               3.57198 0.689667 0 3.559 0.690667 0 3.546 0.691 0 3.51567 0.689539 0
               3.51567 0.689539 0 3.48726 0.685227 0 3.46092 0.678172 0 3.46092 0.678172 0
               3.43678 0.668482 0 3.43678 0.668482 0 3.41497 0.656263 0 3.39563 0.641625 0
               3.39563 0.641625 0 3.37889 0.624674 0 3.37889 0.624674 0 3.36489 0.605519 0
               3.36489 0.605519 0 3.35377 0.584266 0 3.35377 0.584266 0 3.34565 0.561023 0
               3.34069 0.535899 0 3.34069 0.535899 0 3.339 0.509 0 3.3448 0.465641 0
               3.36085 0.42838 0 3.38509 0.396187 0 3.41548 0.368037 0 3.44997 0.3429 0
               3.4865 0.31975 0 3.52303 0.297558 0 3.52303 0.297558 0 3.55752 0.275296 0
               3.58791 0.251937 0 3.58791 0.251937 0 3.61215 0.226454 0 3.61215 0.226454 0
               3.6282 0.197817 0 3.634 0.165 0 3.63327 0.155325 0 3.63106 0.145435 0
               3.62734 0.135531 0 3.62211 0.125815 0 3.61534 0.116487 0 3.61534 0.116487 0
               3.607 0.10775 0 3.607 0.10775 0 3.59708 0.0998044 0 3.59708 0.0998044 0
               3.58556 0.0928518 0 3.57241 0.0870937 0 3.57241 0.0870937 0 3.55761 0.0827315 0
               3.54115 0.0799664 0 3.523 0.079 0 3.523 0.079 0 3.50634 0.0797257 0
               3.48988 0.0818889 0 3.47364 0.0854688 0 3.45767 0.0904444 0 3.44198 0.0967951 0
               3.42663 0.1045 0 3.41162 0.113538 0 3.397 0.123889 0 3.3828 0.135531 0
               3.36904 0.148444 0 3.35577 0.162608 0 3.343 0.178 0 3.343 0.054 0
               3.343 0.054 0 3.35732 0.0437274 0 3.35732 0.0437274 0 3.3718 0.0344028 0
               3.38648 0.0260156 0 3.38648 0.0260156 0 3.40141 0.0185556 0 3.40141 0.0185556 0
               3.41661 0.0120122 0 3.43213 0.006375 0 3.448 0.00163368 0 3.448 0.00163368 0
               3.46426 -0.00222222 0 3.46426 -0.00222222 0 3.48095 -0.00520313 0 3.49812 -0.00731945 0
               3.51579 -0.0085816 0 3.534 -0.009 0 3.56087 -0.00740336 0 3.58634 -0.00272685 0
               3.58634 -0.00272685 0 3.61025 0.00485938 0 3.61025 0.00485938 0 3.63241 0.0151852 0
               3.63241 0.0151852 0 3.65263 0.0280804 0 3.67075 0.043375 0 3.67075 0.043375 0
               3.68657 0.0608987 0 3.68657 0.0608987 0 3.69993 0.0804815 0 3.69993 0.0804815 0
               3.71063 0.101953 0 3.71063 0.101953 0 3.71849 0.125144 0 3.71849 0.125144 0
               3.72334 0.149883 0 3.725 0.176 0 3.7192 0.225891 0 3.7192 0.225891 0
               3.70315 0.26788 0 3.70315 0.26788 0 3.67891 0.303187 0 3.67891 0.303187 0
               3.64852 0.333037 0 3.61403 0.35865 0 3.5775 0.38125 0 3.54097 0.402058 0
               3.50648 0.422296 0 3.47609 0.443187 0 3.45185 0.465954 0 3.43581 0.491817 0
               3.43 0.522 0 3.43092 0.533677 0 3.43363 0.544667 0 3.43363 0.544667 0
               3.43802 0.554906 0 3.43802 0.554906 0 3.444 0.564333 0 3.45148 0.572885 0
               3.46038 0.5805 0 3.47058 0.587115 0 3.482 0.592667 0 3.482 0.592667 0
               3.49455 0.597094 0 3.49455 0.597094 0 3.50813 0.600333 0 3.52264 0.602323 0
               3.538 0.603 0 3.538 0.603 0 3.5497 0.602653 0 3.5618 0.60156 0
               3.5618 0.60156 0 3.57425 0.599641 0 3.58704 0.596815 0 3.60013 0.593003 0
               3.6135 0.588125 0 3.62712 0.582101 0 3.64096 0.574852 0 3.655 0.566297 0
               3.6692 0.556357 0 3.68355 0.544951 0 3.698 0.532 0 3.299 0.682 0
               3.202 0.682 0 2.998 0.203 0 2.793 0.682 0 2.793 0.682 0
               2.695 0.682 0 2.99 -0.006 0 2.99 -0.006 0 3.01 -0.006 0
               2.257 -0.118 0 2.2759 -0.111634 0 2.2931 -0.103653 0 2.30861 -0.0942344 0
               2.32244 -0.0835556 0 2.33461 -0.0717934 0 2.34513 -0.059125 0 2.35399 -0.0457274 0
               2.36122 -0.0317778 0 2.36683 -0.0174531 0 2.37082 -0.00293056 0 2.37082 -0.00293056 0
               2.37321 0.0116128 0 2.374 0.026 0 2.374 0.026 0 2.37342 0.0403027 0
               2.37173 0.0536713 0 2.37173 0.0536713 0 2.36895 0.0660469 0 2.36515 0.0773704 0
               2.36036 0.0875828 0 2.35463 0.096625 0 2.348 0.104438 0 2.348 0.104438 0
               2.34052 0.110963 0 2.34052 0.110963 0 2.33223 0.116141 0 2.33223 0.116141 0
               2.32319 0.119912 0 2.31343 0.122218 0 2.31343 0.122218 0 2.303 0.123 0
               2.2947 0.122509 0 2.2947 0.122509 0 2.28682 0.121069 0 2.28682 0.121069 0
               2.27944 0.118734 0 2.27944 0.118734 0 2.27259 0.115556 0 2.27259 0.115556 0
               2.26634 0.111585 0 2.26634 0.111585 0 2.26075 0.106875 0 2.26075 0.106875 0
               2.25586 0.101477 0 2.25586 0.101477 0 2.25174 0.0954444 0 2.24844 0.0888281 0
               2.24601 0.0816806 0 2.24451 0.0740538 0 2.244 0.066 0 2.24441 0.057985 0
               2.24441 0.057985 0 2.24562 0.050463 0 2.24562 0.050463 0 2.24758 0.0434688 0
               2.25026 0.037037 0 2.25026 0.037037 0 2.25362 0.0312025 0 2.25362 0.0312025 0
               2.25762 0.026 0 2.26223 0.0214641 0 2.26741 0.0176296 0 2.27311 0.0145313 0
               2.2793 0.0122037 0 2.28594 0.0106817 0 2.293 0.01 0 2.293 0.01 0
               2.29481 0.000712964 0 2.29481 0.000712964 0 2.29575 -0.0090463 0 2.29581 -0.019125 0
               2.295 -0.0293704 0 2.29331 -0.0396296 0 2.29075 -0.04975 0 2.28731 -0.0595787 0
               2.283 -0.068963 0 2.27781 -0.07775 0 2.27175 -0.085787 0 2.26481 -0.0929213 0
               2.257 -0.099 0 1.919 0.458 0 1.88619 0.455958 0 1.85492 0.449995 0
               1.85492 0.449995 0 1.82544 0.440359 0 1.82544 0.440359 0 1.798 0.427296 0
               1.77285 0.411053 0 1.75025 0.391875 0 1.73044 0.37001 0 1.71367 0.345704 0
               1.71367 0.345704 0 1.70019 0.319203 0 1.70019 0.319203 0 1.69025 0.290755 0
               1.69025 0.290755 0 1.6841 0.260605 0 1.6841 0.260605 0 1.682 0.229 0
               1.682 0.229 0 1.68403 0.195328 0 1.68997 0.163454 0 1.68997 0.163454 0
               1.69963 0.133594 0 1.69963 0.133594 0 1.71278 0.105963 0 1.72922 0.0807766 0
               1.72922 0.0807766 0 1.74875 0.05825 0 1.74875 0.05825 0 1.77115 0.0385984 0
               1.77115 0.0385984 0 1.79622 0.022037 0 1.79622 0.022037 0 1.82375 0.00878121 0
               1.85353 -0.000953747 0 1.88535 -0.00695259 0 1.919 -0.009 0 1.95403 -0.00702894 0
               1.987 -0.00123148 0 2.01772 0.00821875 0 2.046 0.0211482 0 2.07166 0.0373831 0
               2.07166 0.0373831 0 2.0945 0.05675 0 2.0945 0.05675 0 2.11434 0.0790752 0
               2.131 0.104185 0 2.14428 0.131906 0 2.14428 0.131906 0 2.154 0.162065 0
               2.154 0.162065 0 2.15997 0.194487 0 2.162 0.229 0 2.15991 0.261445 0
               2.15379 0.292144 0 2.14386 0.320891 0 2.13033 0.347482 0 2.11343 0.371711 0
               2.09338 0.393375 0 2.07038 0.412268 0 2.04467 0.428185 0 2.04467 0.428185 0
               2.01645 0.440922 0 2.01645 0.440922 0 1.98596 0.450273 0 1.9534 0.456034 0
               1.918 0.378 0 1.93971 0.37671 0 1.96024 0.372931 0 1.97945 0.366797 0
               1.99722 0.358444 0 2.01341 0.348009 0 2.02787 0.335625 0 2.04049 0.321429 0
               2.05111 0.305556 0 2.05961 0.288141 0 2.06585 0.26932 0 2.06969 0.249227 0
               2.071 0.228 0 2.06978 0.204534 0 2.06619 0.18269 0 2.06031 0.162547 0
               2.05222 0.144185 0 2.05222 0.144185 0 2.04201 0.127685 0 2.02975 0.113125 0
               2.01553 0.100586 0 1.99944 0.0901482 0 1.98156 0.0818907 0 1.96197 0.0758935 0
               1.96197 0.0758935 0 1.94076 0.0722367 0 1.94076 0.0722367 0 1.918 0.071 0
               1.918 0.071 0 1.89708 0.0722946 0 1.89708 0.0722946 0 1.8774 0.0761065 0
               1.8774 0.0761065 0 1.85906 0.0823281 0 1.85906 0.0823281 0 1.84219 0.0908519 0
               1.82688 0.10157 0 1.82688 0.10157 0 1.81325 0.114375 0 1.80141 0.129159 0
               1.79148 0.145815 0 1.79148 0.145815 0 1.78356 0.164234 0 1.78356 0.164234 0
               1.77777 0.18431 0 1.77421 0.205935 0 1.773 0.229 0 1.773 0.229 0
               1.77425 0.249998 0 1.77425 0.249998 0 1.77791 0.269898 0 1.78384 0.288563 0
               1.78384 0.288563 0 1.79193 0.305852 0 1.79193 0.305852 0 1.80202 0.321627 0
               1.80202 0.321627 0 1.814 0.33575 0 1.814 0.33575 0 1.82773 0.348081 0
               1.82773 0.348081 0 1.84307 0.358482 0 1.84307 0.358482 0 1.85991 0.366813 0
               1.85991 0.366813 0 1.87809 0.372935 0 1.8975 0.376711 0 1.581 0.682 0
               1.492 0.682 0 1.492 0 0 1.581 0 0 1.362 0.682 0
               1.273 0.682 0 1.273 0 0 1.362 0 0 1.167 0.13 0
               1.15402 0.121795 0 1.14106 0.114194 0 1.12812 0.107219 0 1.11519 0.100889 0
               1.10223 0.0952257 0 1.08925 0.09025 0 1.07623 0.0859826 0 1.06315 0.0824444 0
               1.05 0.0796563 0 1.05 0.0796563 0 1.03677 0.0776389 0 1.03677 0.0776389 0
               1.02344 0.0764132 0 1.01 0.076 0 0.98923 0.0769566 0 0.98923 0.0769566 0
               0.969926 0.0798194 0 0.952094 0.0845781 0 0.952094 0.0845781 0 0.935741 0.0912222 0
               0.920874 0.0997413 0 0.9075 0.110125 0 0.9075 0.110125 0 0.895626 0.122363 0
               0.885259 0.136444 0 0.885259 0.136444 0 0.876406 0.152359 0 0.876406 0.152359 0
               0.869074 0.170097 0 0.869074 0.170097 0 0.86327 0.189648 0 0.86327 0.189648 0
               0.859 0.211 0 0.859 0.211 0 1.175 0.211 0 1.175 0.211 0
               1.17344 0.250731 0 1.17344 0.250731 0 1.16882 0.286935 0 1.16127 0.319625 0
               1.16127 0.319625 0 1.15089 0.348815 0 1.15089 0.348815 0 1.1378 0.374519 0
               1.1378 0.374519 0 1.12212 0.39675 0 1.12212 0.39675 0 1.10397 0.415523 0
               1.08344 0.430852 0 1.06067 0.44275 0 1.06067 0.44275 0 1.03576 0.451232 0
               1.00884 0.45631 0 0.98 0.458 0 0.949819 0.456111 0 0.921389 0.450556 0
               0.921389 0.450556 0 0.894875 0.4415 0 0.894875 0.4415 0 0.870444 0.429111 0
               0.848264 0.413556 0 0.8285 0.395 0 0.8285 0.395 0 0.811319 0.373611 0
               0.796889 0.349556 0 0.785375 0.323 0 0.776944 0.294111 0 0.771764 0.263056 0
               0.77 0.23 0 0.77 0.23 0 0.771616 0.199249 0 0.771616 0.199249 0
               0.776426 0.169241 0 0.776426 0.169241 0 0.784375 0.140344 0 0.784375 0.140344 0
               0.795407 0.112926 0 0.795407 0.112926 0 0.809468 0.0873553 0 0.809468 0.0873553 0
               0.8265 0.064 0 0.8265 0.064 0 0.846449 0.043228 0 0.869259 0.0254074 0
               0.894875 0.0109063 0 0.923241 9.26116e-05 0 0.954301 -0.00666549 0 0.988 -0.009 0
               0.988 -0.009 0 1.00646 -0.00864468 0 1.0239 -0.00757407 0 1.0239 -0.00757407 0
               1.04044 -0.00578125 0 1.05619 -0.00325926 0 1.07125 -1.1567e-06 0 1.08575 0.004 0
               1.09979 0.00875116 0 1.11348 0.0142593 0 1.12694 0.0205313 0 1.14027 0.0275741 0
               1.15359 0.0353947 0 1.167 0.044 0 1.167 0.044 0 0.861 0.27 0
               0.864603 0.287099 0 0.869407 0.302875 0 0.875406 0.317297 0 0.882593 0.330333 0
               0.89096 0.341953 0 0.9005 0.352125 0 0.911207 0.360818 0 0.923074 0.368 0
               0.936094 0.373641 0 0.950259 0.377708 0 0.965564 0.380172 0 0.982 0.381 0
               0.997243 0.380115 0 1.01144 0.3775 0 1.02456 0.373219 0 1.03656 0.367333 0
               1.04738 0.359906 0 1.057 0.351 0 1.057 0.351 0 1.06537 0.340677 0
               1.06537 0.340677 0 1.07244 0.329 0 1.07244 0.329 0 1.07819 0.316031 0
               1.08256 0.301833 0 1.08551 0.286469 0 1.08551 0.286469 0 1.087 0.27 0
               1.087 0.27 0 0.653 0.682 0 0.653 0.682 0 0.555 0.682 0
               0.555 0.385 0 0.555 0.385 0 0.173 0.385 0 0.173 0.682 0
               0.075 0.682 0 0.075 0 0 0.173 0 0 0.173 0.297 0
               0.555 0.297 0 0.555 0 0 0.653 0 0
            }
            Array id=8 vsg::vec3Array
            {
              NumUserObjects 0
              Layout 0 12 0 1 1 1 0 -1
              Size 679
              Storage id=0
              Data 0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1 0 0 1
               0 0 1 0 0 1 0 0 1
            }
            Array id=9 vsg::vec2Array
            {
              NumUserObjects 0
              Layout 0 8 0 1 1 1 0 -1
              Size 679
              Storage id=0
              Data 0 1 0.00990099 1 0.019802 1 0.029703 1 0.039604 1 0.049505 1
               0.0594059 1 0.0693069 1 0.0792079 1 0.0891089 1 0.0990099 1 0.108911 1
               0.118812 1 0.128713 1 0.138614 1 0.148515 1 0.158416 1 0.158416 1
               0.168317 1 0.178218 1 0.178218 1 0.188119 1 0.19802 1 0.19802 1
               0.207921 1 0.207921 1 0.217822 1 0.217822 1 0.227723 1 0.227723 1
               0.237624 1 0.247525 1 0.257426 1 0.257426 1 0.267327 1 0.277228 1
               0.277228 1 0.287129 1 0.287129 1 0.29703 1 0.306931 1 0.316832 1
               0.316832 1 0.326733 1 0.326733 1 0.336634 1 0.346535 1 0.356436 1
               0.366337 1 0.376238 1 0.386139 1 0.386139 1 0.39604 1 0.39604 1
               0.405941 1 0.415842 1 0.415842 1 0.425743 1 0.435644 1 0.445545 1
               0.455446 1 0.465347 1 0.475248 1 0.485149 1 0.49505 1 0.49505 1
               0.504951 1 0.504951 1 0.514852 1 0.524752 1 0.524752 1 0.534653 1
               0.544554 1 0.554455 1 0.564356 1 0.574257 1 0.584158 1 0.594059 1
               0.60396 1 0.613861 1 0.623762 1 0.633663 1 0.643564 1 0.653465 1
               0.663366 1 0.673267 1 0.683168 1 0.693069 1 0.693069 1 0.70297 1
               0.70297 1 0.712871 1 0.722772 1 0.732673 1 0.732673 1 0.742574 1
               0.752475 1 0.752475 1 0.762376 1 0.762376 1 0.772277 1 0.772277 1
               0.782178 1 0.782178 1 0.792079 1 0.80198 1 0.80198 1 0.811881 1
               0.811881 1 0.821782 1 0.821782 1 0.831683 1 0.831683 1 0.841584 1
               0.851485 1 0.861386 1 0.861386 1 0.871287 1 0.871287 1 0.881188 1
               0.881188 1 0.891089 1 0.90099 1 0.90099 1 0.910891 1 0.920792 1
               0.930693 1 0.930693 1 0.940594 1 0.950495 1 0.960396 1 0.970297 1
               0.980198 1 0.990099 1 1 1 0 1 0.00826446 1 0.0165289 1
               0.0247934 1 0.0330578 1 0.0413223 1 0.0413223 1 0.0495868 1 0.0578512 1
               0.0661157 1 0.0743802 1 0.0743802 1 0.0826446 1 0.0826446 1 0.0909091 1
               0.0991736 1 0.107438 1 0.107438 1 0.115702 1 0.123967 1 0.123967 1
               0.132231 1 0.132231 1 0.140496 1 0.14876 1 0.14876 1 0.157025 1
               0.157025 1 0.165289 1 0.165289 1 0.173554 1 0.173554 1 0.181818 1
               0.190083 1 0.190083 1 0.198347 1 0.206612 1 0.214876 1 0.22314 1
               0.231405 1 0.239669 1 0.247934 1 0.256198 1 0.256198 1 0.264463 1
               0.272727 1 0.272727 1 0.280992 1 0.280992 1 0.289256 1 0.297521 1
               0.305785 1 0.31405 1 0.322314 1 0.330579 1 0.338843 1 0.338843 1
               0.347107 1 0.347107 1 0.355372 1 0.355372 1 0.363636 1 0.371901 1
               0.371901 1 0.380165 1 0.38843 1 0.396694 1 0.396694 1 0.404959 1
               0.413223 1 0.421488 1 0.429752 1 0.438017 1 0.446281 1 0.454545 1
               0.46281 1 0.471074 1 0.479339 1 0.487603 1 0.495868 1 0.504132 1
               0.504132 1 0.512397 1 0.512397 1 0.520661 1 0.528926 1 0.528926 1
               0.53719 1 0.53719 1 0.545455 1 0.553719 1 0.561983 1 0.561983 1
               0.570248 1 0.570248 1 0.578512 1 0.586777 1 0.595041 1 0.603306 1
               0.61157 1 0.619835 1 0.619835 1 0.628099 1 0.628099 1 0.636364 1
               0.636364 1 0.644628 1 0.652893 1 0.652893 1 0.661157 1 0.661157 1
               0.669421 1 0.669421 1 0.677686 1 0.677686 1 0.68595 1 0.68595 1
               0.694215 1 0.702479 1 0.710744 1 0.710744 1 0.719008 1 0.719008 1
               0.727273 1 0.727273 1 0.735537 1 0.743802 1 0.752066 1 0.760331 1
               0.768595 1 0.77686 1 0.785124 1 0.793388 1 0.801653 1 0.809917 1
               0.818182 1 0.818182 1 0.826446 1 0.826446 1 0.834711 1 0.842975 1
               0.85124 1 0.859504 1 0.867769 1 0.867769 1 0.876033 1 0.876033 1
               0.884298 1 0.892562 1 0.900826 1 0.900826 1 0.909091 1 0.917355 1
               0.917355 1 0.92562 1 0.933884 1 0.942149 1 0.950413 1 0.958678 1
               0.966942 1 0.975207 1 0.983471 1 0.991736 1 1 1 0 1
               0.166667 1 0.333333 1 0.5 1 0.5 1 0.666667 1 0.833333 1
               0.833333 1 1 1 0 1 0.0166667 1 0.0333333 1 0.05 1
               0.0666667 1 0.0833333 1 0.1 1 0.116667 1 0.133333 1 0.15 1
               0.166667 1 0.166667 1 0.183333 1 0.2 1 0.2 1 0.216667 1
               0.233333 1 0.233333 1 0.25 1 0.266667 1 0.283333 1 0.3 1
               0.316667 1 0.316667 1 0.333333 1 0.333333 1 0.35 1 0.35 1
               0.366667 1 0.383333 1 0.383333 1 0.4 1 0.416667 1 0.416667 1
               0.433333 1 0.433333 1 0.45 1 0.45 1 0.466667 1 0.466667 1
               0.483333 1 0.483333 1 0.5 1 0.5 1 0.516667 1 0.516667 1
               0.533333 1 0.55 1 0.566667 1 0.583333 1 0.6 1 0.616667 1
               0.616667 1 0.633333 1 0.633333 1 0.65 1 0.666667 1 0.666667 1
               0.683333 1 0.683333 1 0.7 1 0.716667 1 0.733333 1 0.75 1
               0.766667 1 0.783333 1 0.8 1 0.8 1 0.816667 1 0.816667 1
               0.833333 1 0.85 1 0.866667 1 0.883333 1 0.9 1 0.916667 1
               0.933333 1 0.95 1 0.966667 1 0.983333 1 1 1 0 1
               0.0105263 1 0.0210526 1 0.0210526 1 0.0315789 1 0.0315789 1 0.0421053 1
               0.0526316 1 0.0631579 1 0.0736842 1 0.0842105 1 0.0842105 1 0.0947368 1
               0.0947368 1 0.105263 1 0.105263 1 0.115789 1 0.115789 1 0.126316 1
               0.126316 1 0.136842 1 0.147368 1 0.147368 1 0.157895 1 0.157895 1
               0.168421 1 0.178947 1 0.178947 1 0.189474 1 0.189474 1 0.2 1
               0.2 1 0.210526 1 0.210526 1 0.221053 1 0.231579 1 0.242105 1
               0.252632 1 0.263158 1 0.273684 1 0.284211 1 0.294737 1 0.305263 1
               0.305263 1 0.315789 1 0.315789 1 0.326316 1 0.336842 1 0.347368 1
               0.347368 1 0.357895 1 0.357895 1 0.368421 1 0.378947 1 0.389474 1
               0.4 1 0.410526 1 0.421053 1 0.431579 1 0.442105 1 0.452632 1
               0.463158 1 0.463158 1 0.473684 1 0.473684 1 0.484211 1 0.494737 1
               0.505263 1 0.515789 1 0.526316 1 0.536842 1 0.547368 1 0.557895 1
               0.568421 1 0.578947 1 0.589474 1 0.6 1 0.610526 1 0.621053 1
               0.631579 1 0.642105 1 0.652632 1 0.663158 1 0.673684 1 0.673684 1
               0.684211 1 0.694737 1 0.705263 1 0.715789 1 0.726316 1 0.736842 1
               0.736842 1 0.747368 1 0.747368 1 0.757895 1 0.757895 1 0.768421 1
               0.768421 1 0.778947 1 0.778947 1 0.789474 1 0.789474 1 0.8 1
               0.810526 1 0.810526 1 0.821053 1 0.831579 1 0.842105 1 0.842105 1
               0.852632 1 0.852632 1 0.863158 1 0.873684 1 0.884211 1 0.884211 1
               0.894737 1 0.894737 1 0.905263 1 0.915789 1 0.915789 1 0.926316 1
               0.926316 1 0.936842 1 0.936842 1 0.947368 1 0.947368 1 0.957895 1
               0.957895 1 0.968421 1 0.968421 1 0.978947 1 0.978947 1 0.989474 1
               1 1 0 1 0.333333 1 0.666667 1 1 1 0 1
               0.333333 1 0.666667 1 1 1 0 1 0.0102041 1 0.0204082 1
               0.0306122 1 0.0408163 1 0.0510204 1 0.0612245 1 0.0714286 1 0.0816327 1
               0.0918367 1 0.0918367 1 0.102041 1 0.102041 1 0.112245 1 0.122449 1
               0.132653 1 0.132653 1 0.142857 1 0.153061 1 0.153061 1 0.163265 1
               0.173469 1 0.183673 1 0.183673 1 0.193878 1 0.204082 1 0.204082 1
               0.214286 1 0.214286 1 0.22449 1 0.22449 1 0.234694 1 0.234694 1
               0.244898 1 0.244898 1 0.255102 1 0.255102 1 0.265306 1 0.265306 1
               0.27551 1 0.285714 1 0.285714 1 0.295918 1 0.295918 1 0.306122 1
               0.306122 1 0.316327 1 0.316327 1 0.326531 1 0.336735 1 0.346939 1
               0.346939 1 0.357143 1 0.367347 1 0.377551 1 0.387755 1 0.397959 1
               0.397959 1 0.408163 1 0.408163 1 0.418367 1 0.428571 1 0.438776 1
               0.438776 1 0.44898 1 0.459184 1 0.469388 1 0.479592 1 0.489796 1
               0.5 1 0.5 1 0.510204 1 0.510204 1 0.520408 1 0.520408 1
               0.530612 1 0.530612 1 0.540816 1 0.540816 1 0.55102 1 0.55102 1
               0.561224 1 0.561224 1 0.571429 1 0.581633 1 0.591837 1 0.602041 1
               0.612245 1 0.622449 1 0.622449 1 0.632653 1 0.642857 1 0.642857 1
               0.653061 1 0.663265 1 0.673469 1 0.683673 1 0.693878 1 0.704082 1
               0.714286 1 0.72449 1 0.734694 1 0.744898 1 0.744898 1 0.755102 1
               0.765306 1 0.77551 1 0.785714 1 0.795918 1 0.806122 1 0.816327 1
               0.826531 1 0.836735 1 0.846939 1 0.857143 1 0.867347 1 0.877551 1
               0.887755 1 0.897959 1 0.908163 1 0.918367 1 0.928571 1 0.938776 1
               0.938776 1 0.94898 1 0.94898 1 0.959184 1 0.959184 1 0.969388 1
               0.979592 1 0.989796 1 0.989796 1 1 1 1 1 0 1
               0 1 0.0909091 1 0.181818 1 0.181818 1 0.272727 1 0.363636 1
               0.454545 1 0.545455 1 0.636364 1 0.727273 1 0.818182 1 0.909091 1
               1 1
            }
            Indices id=10 vsg::ushortArray
            {
              NumUserObjects 0
              Layout 0 2 0 1 1 1 0 -1
              Size 1479
              Storage id=0
              Data 2 0 1 2 3 0 3 134 0 4 134 3
               5 134 4 6 134 5 7 134 6 8 134 7
               9 134 8 10 134 9 11 134 10 12 134 11
               13 134 12 14 134 13 15 134 14 17 134 15
               112 134 17 113 134 112 113 133 134 113 132 133
               114 132 113 114 131 132 114 130 131 116 130 114
               116 129 130 116 128 129 116 127 128 118 125 127
               118 124 125 118 123 124 120 121 123 111 16 18
               111 18 109 109 18 19 110 20 21 110 23 108
               110 21 23 108 27 106 108 25 27 106 29 104
               104 29 30 104 31 103 104 30 31 103 31 33
               101 33 34 101 34 99 99 34 36 107 22 24
               105 26 28 102 32 100 98 35 37 98 37 96
               97 38 39 97 39 95 95 39 40 95 42 94
               95 40 42 94 44 92 92 44 45 92 46 91
               92 45 46 91 46 47 91 48 90 91 47 48
               90 48 49 90 53 88 90 49 51 53 54 88
               88 71 86 88 70 71 54 56 88 86 71 72
               86 73 85 86 72 73 85 73 74 85 75 84
               85 74 75 84 75 76 84 78 83 84 77 78
               84 76 77 83 78 79 83 81 82 83 80 81
               83 79 80 56 57 70 57 58 70 58 59 70
               59 60 70 60 61 70 61 62 70 62 63 70
               63 65 70 67 68 70 93 41 43 89 50 52
               87 55 69 64 66 69 117 126 115 119 122 117
               160 135 136 160 290 135 290 291 135 291 292 135
               292 293 135 293 294 135 294 295 135 295 296 135
               296 297 135 297 298 135 289 290 160 288 289 160
               160 136 158 158 136 137 158 138 157 158 137 138
               157 138 139 157 139 141 155 141 142 155 143 153
               155 142 143 153 143 144 153 146 152 153 144 146
               152 149 150 152 148 149 286 288 162 285 286 162
               283 285 164 166 283 164 166 282 283 166 281 282
               166 277 279 166 276 277 167 276 166 167 275 276
               167 274 275 167 273 274 169 273 167 169 269 271
               170 269 169 170 268 269 170 267 268 171 267 170
               171 266 267 171 265 266 172 265 171 172 264 265
               173 264 172 173 263 264 173 262 263 174 262 173
               174 261 262 175 261 174 175 260 261 176 260 175
               176 259 260 178 259 176 179 257 178 181 257 179
               181 255 257 184 255 183 184 253 255 185 253 184
               185 252 253 186 252 185 187 252 186 187 251 252
               188 251 187 189 251 188 191 251 189 156 140 154
               151 145 147 161 287 159 163 284 161 165 278 280
               168 270 272 177 256 258 182 254 180 190 248 250
               192 248 190 195 249 193 195 247 249 199 247 198
               200 247 199 200 245 247 202 245 200 216 202 203
               216 203 204 216 204 205 216 205 206 216 206 207
               216 207 208 216 208 209 216 209 210 216 210 211
               216 211 212 216 212 213 216 213 214 196 246 194
               197 246 196 215 244 201 215 242 244 217 242 215
               219 243 218 219 241 243 221 241 219 221 240 241
               224 240 223 224 238 240 225 238 224 227 238 225
               222 239 220 226 235 237 228 235 226 230 236 229
               230 234 236 231 234 230 232 234 231 232 233 234
               301 299 300 301 307 299 306 301 303 306 307 301
               305 302 304 308 310 388 308 309 310 388 310 311
               388 311 387 386 311 312 387 311 386 386 312 385
               385 312 313 385 313 384 383 313 314 384 313 383
               383 314 382 382 314 315 382 315 381 381 315 316
               381 316 380 379 316 317 380 316 379 379 317 378
               378 317 319 378 319 377 375 319 320 373 375 320
               369 320 322 370 320 369 371 320 370 372 320 371
               373 320 372 369 322 368 365 322 323 368 322 367
               365 323 363 362 323 325 363 323 362 358 325 326
               360 325 358 358 326 357 357 326 327 357 327 356
               356 327 328 356 328 355 354 328 329 355 328 354
               354 329 353 353 329 331 351 331 333 351 333 349
               347 333 335 345 335 336 345 336 343 343 336 338
               341 338 339 376 318 374 366 321 364 361 324 359
               352 330 350 348 332 346 346 334 344 342 337 340
               390 455 389 390 454 455 392 454 390 392 453 454
               393 452 391 393 450 452 395 451 394 395 449 451
               396 449 395 396 448 449 397 448 396 397 447 448
               398 456 397 456 447 397 457 447 456 458 447 457
               459 447 458 459 446 447 398 522 456 398 521 522
               398 520 521 400 520 398 400 516 518 402 514 400
               402 512 514 404 510 402 406 508 404 406 506 508
               406 505 506 460 446 459 461 446 460 462 446 461
               462 445 446 463 445 462 464 445 463 464 444 445
               465 444 464 465 443 444 466 443 465 467 443 466
               467 442 443 468 442 467 468 441 442 469 441 468
               470 441 469 470 440 441 471 440 470 473 440 471
               474 438 473 474 436 438 475 436 474 476 436 475
               476 435 436 477 435 476 478 435 477 480 435 478
               480 434 435 484 434 482 420 434 418 418 484 486
               399 517 519 399 513 515 401 509 511 403 507 509
               407 504 405 407 502 504 409 503 408 409 501 503
               409 500 501 411 500 409 411 499 500 410 496 498
               412 496 410 413 495 497 414 495 413 414 494 495
               414 493 494 416 493 414 416 488 490 415 491 492
               415 489 491 417 487 415 417 485 487 417 433 483
               481 433 479 419 431 433 421 431 419 422 430 432
               423 430 422 423 429 430 424 429 423 424 428 429
               425 428 424 425 427 428 426 427 425 472 437 439
               525 523 524 525 526 523 529 527 528 529 530 527
               532 634 531 533 634 532 534 634 533 535 634 534
               536 634 535 537 634 536 538 634 537 539 634 538
               541 634 539 544 634 543 545 634 544 613 634 545
               614 634 613 614 632 634 613 545 547 613 550 611
               611 550 551 611 552 554 611 551 552 609 554 555
               609 555 557 607 557 559 607 559 605 605 561 563
               603 563 565 603 565 601 601 569 599 601 567 569
               662 569 570 599 569 664 599 636 598 599 635 636
               599 664 635 598 636 637 598 638 597 598 637 638
               597 638 639 597 640 596 597 639 640 596 640 641
               596 643 595 596 642 643 596 641 642 595 643 644
               595 647 594 595 646 647 595 645 646 595 644 645
               647 576 594 648 576 647 594 578 592 592 578 579
               592 579 591 591 579 580 591 580 590 590 580 582
               588 582 583 588 583 586 586 583 584 586 584 585
               649 576 648 650 576 649 650 574 576 651 574 650
               652 574 651 654 574 652 656 572 574 659 572 658
               659 570 572 660 570 659 662 570 660 615 632 614
               615 631 632 615 630 631 616 630 615 616 629 630
               616 628 629 617 628 616 617 627 628 617 626 627
               618 626 617 618 625 626 618 624 625 618 623 624
               620 623 618 542 633 540 612 546 548 612 548 549
               610 553 608 608 556 606 604 558 560 604 562 602
               564 566 600 663 568 661 657 571 655 655 573 653
               593 575 577 589 581 587 619 621 622 668 665 667
               669 678 666 675 669 670 675 676 669 676 678 669
               677 678 676 673 675 670 673 674 675 673 670 671
               673 671 672
            }
            indexCount 1479
            instanceCount 1
            firstIndex 0
            vertexOffset 0
            firstInstance 0
          }
          NumStateCommands 2
          StateCommand id=11 vsg::BindGraphicsPipeline
          {
            NumUserObjects 0
            Slot 0
            GraphicsPipeline id=12 vsg::GraphicsPipeline
            {
              NumUserObjects 0
              PipelineLayout id=13 vsg::PipelineLayout
              {
                NumUserObjects 0
                Flags 0
                NumDescriptorSetLayouts 1
                DescriptorSetLayout id=14 vsg::DescriptorSetLayout
                {
                  NumUserObjects 0
                  NumDescriptorSetLayoutBindings 1
                  binding 10
                  descriptorType 6
                  descriptorCount 1
                  stageFlags 16
                }
                NumPushConstantRanges 1
                stageFlags 1
                offset 0
                size 128
              }
              NumShaderStages 2
              ShaderStage id=15 vsg::ShaderStage
              {
                NumUserObjects 0
                Stage 1
                EntryPoint "main"
                ShaderModule id=16 vsg::ShaderModule
                {
                  NumUserObjects 0
                  Source "#version 450

#extension GL_ARB_separate_shader_objects : enable

layout(push_constant) uniform PushConstants {
    mat4 projection;
    mat4 modelView;
} pc;

layout(location = 0) in vec3 osg_Vertex;
layout(location = 0) out vec3 worldPos;

layout(location = 1) in vec3 osg_Normal;
layout(location = 1) out vec3 normalDir;

layout(location = 2) in vec2 osg_TexCoord0;
layout(location = 2) out vec2 texCoord0;

layout(location = 5) out vec3 viewDir;
layout(location = 6) out vec3 lightDir;

out gl_PerVertex{ vec4 gl_Position; };

void main()
{
    gl_Position = (pc.projection * pc.modelView) * vec4(osg_Vertex, 1.0);
    worldPos = vec4(pc.modelView * vec4(osg_Vertex, 1.0)).xyz;

    vec3 n = (pc.modelView * vec4(osg_Normal, 0.0)).xyz;
    normalDir = n;
    vec4 lpos = /*osg_LightSource.position*/ vec4(0.0, 0.25, 1.0, 0.0);
    viewDir = -vec3(pc.modelView * vec4(osg_Vertex, 1.0));

    if (lpos.w == 0.0)
        lightDir = lpos.xyz;
    else
        lightDir = lpos.xyz + viewDir;

    texCoord0 = osg_TexCoord0 * vec2(1,1);
}
"
                  SPIRVSize 0
                  SPIRV
                }
                NumSpecializationConstants 0
              }
              ShaderStage id=17 vsg::ShaderStage
              {
                NumUserObjects 0
                Stage 16
                EntryPoint "main"
                ShaderModule id=18 vsg::ShaderModule
                {
                  NumUserObjects 0
                  Source "#version 450
#pragma import_defines (VSG_DIFFUSE_MAP, VSG_EMISSIVE_MAP, VSG_LIGHTMAP_MAP, VSG_NORMAL_MAP, VSG_METALLROUGHNESS_MAP, VSG_SPECULAR_MAP, VSG_TWOSIDED, VSG_WORKFLOW_SPECGLOSS)
#define VSG_TWOSIDED

#extension GL_ARB_separate_shader_objects : enable

const float PI = 3.14159265359;
const float RECIPROCAL_PI = 0.31830988618;
const float RECIPROCAL_PI2 = 0.15915494;
const float EPSILON = 1e-6;
const float c_MinRoughness = 0.04;

#ifdef VSG_DIFFUSE_MAP
layout(binding = 0) uniform sampler2D diffuseMap;
#endif

#ifdef VSG_METALLROUGHNESS_MAP
layout(binding = 1) uniform sampler2D mrMap;
#endif

#ifdef VSG_NORMAL_MAP
layout(binding = 2) uniform sampler2D normalMap;
#endif

#ifdef VSG_LIGHTMAP_MAP
layout(binding = 3) uniform sampler2D aoMap;
#endif

#ifdef VSG_EMISSIVE_MAP
layout(binding = 4) uniform sampler2D emissiveMap;
#endif

#ifdef VSG_SPECULAR_MAP
layout(binding = 5) uniform sampler2D specularMap;
#endif

layout(push_constant) uniform PushConstants {
    mat4 projection;
    mat4 modelView;
} pc;

layout(binding = 10) uniform PbrData
{
    vec4 baseColorFactor;
    vec4 emissiveFactor;
    vec4 diffuseFactor;
    vec4 specularFactor;
    float metallicFactor;
    float roughnessFactor;
    float alphaMask;
    float alphaMaskCutoff;
} pbr;

layout(location = 0) in vec3 worldPos;
layout(location = 1) in vec3 normalDir;
layout(location = 2) in vec2 texCoord0;
layout(location = 5) in vec3 viewDir;
layout(location = 6) in vec3 lightDir;

layout(location = 0) out vec4 outColor;


// Encapsulate the various inputs used by the various functions in the shading equation
// We store values in this struct to simplify the integration of alternative implementations
// of the shading terms, outlined in the Readme.MD Appendix.
struct PBRInfo
{
    float NdotL;                  // cos angle between normal and light direction
    float NdotV;                  // cos angle between normal and view direction
    float NdotH;                  // cos angle between normal and half vector
    float LdotH;                  // cos angle between light direction and half vector
    float VdotH;                  // cos angle between view direction and half vector
    float VdotL;                  // cos angle between view direction and light direction
    float perceptualRoughness;    // roughness value, as authored by the model creator (input to shader)
    float metalness;              // metallic value at the surface
    vec3 reflectance0;            // full reflectance color (normal incidence angle)
    vec3 reflectance90;           // reflectance color at grazing angle
    float alphaRoughness;         // roughness mapped to a more linear change in the roughness (proposed by [2])
    vec3 diffuseColor;            // color contribution from diffuse lighting
    vec3 specularColor;           // color contribution from specular lighting
};


vec4 SRGBtoLINEAR(vec4 srgbIn)
{
    vec3 linOut = pow(srgbIn.xyz, vec3(2.2));
    return vec4(linOut,srgbIn.w);
}

vec4 LINEARtoSRGB(vec4 srgbIn)
{
    vec3 linOut = pow(srgbIn.xyz, vec3(1.0 / 2.2));
    return vec4(linOut, srgbIn.w);
}

float rcp(const in float value)
{
    return 1.0 / value;
}

float pow5(const in float value)
{
    return value * value * value * value * value;
}

// Find the normal for this fragment, pulling either from a predefined normal map
// or from the interpolated mesh normal and tangent attributes.
vec3 getNormal()
{
#ifdef VSG_NORMAL_MAP
    // Perturb normal, see http://www.thetenthplanet.de/archives/1180
    vec3 tangentNormal = texture(normalMap, texCoord0).xyz * 2.0 - 1.0;

    //tangentNormal *= vec3(2,2,1);

    vec3 q1 = dFdx(worldPos);
    vec3 q2 = dFdy(worldPos);
    vec2 st1 = dFdx(texCoord0);
    vec2 st2 = dFdy(texCoord0);

    vec3 N = normalize(normalDir);
    vec3 T = normalize(q1 * st2.t - q2 * st1.t);
    vec3 B = -normalize(cross(N, T));
    mat3 TBN = mat3(T, B, N);

    return normalize(TBN * tangentNormal);
#else
    return normalize(normalDir);
#endif
}

// Basic Lambertian diffuse
// Implementation from Lambert's Photometria https://archive.org/details/lambertsphotome00lambgoog
// See also [1], Equation 1
vec3 BRDF_Diffuse_Lambert(PBRInfo pbrInputs)
{
    return pbrInputs.diffuseColor * RECIPROCAL_PI;
}

vec3 BRDF_Diffuse_Custom_Lambert(PBRInfo pbrInputs)
{
    return pbrInputs.diffuseColor * RECIPROCAL_PI * pow(pbrInputs.NdotV, 0.5 + 0.3 * pbrInputs.perceptualRoughness);
}

// [Gotanda 2012, \"Beyond a Simple Physically Based Blinn-Phong Model in Real-Time\"]
vec3 BRDF_Diffuse_OrenNayar(PBRInfo pbrInputs)
{
    float a = pbrInputs.alphaRoughness;
    float s = a;// / ( 1.29 + 0.5 * a );
    float s2 = s * s;
    float VoL = 2 * pbrInputs.VdotH * pbrInputs.VdotH - 1;		// double angle identity
    float Cosri = pbrInputs.VdotL - pbrInputs.NdotV * pbrInputs.NdotL;
    float C1 = 1 - 0.5 * s2 / (s2 + 0.33);
    float C2 = 0.45 * s2 / (s2 + 0.09) * Cosri * ( Cosri >= 0 ? 1.0 / max(pbrInputs.NdotL, pbrInputs.NdotV) : 1 );
    return pbrInputs.diffuseColor / PI * ( C1 + C2 ) * ( 1 + pbrInputs.perceptualRoughness * 0.5 );
}

// [Gotanda 2014, \"Designing Reflectance Models for New Consoles\"]
vec3 BRDF_Diffuse_Gotanda(PBRInfo pbrInputs)
{
    float a = pbrInputs.alphaRoughness;
    float a2 = a * a;
    float F0 = 0.04;
    float VoL = 2 * pbrInputs.VdotH * pbrInputs.VdotH - 1;		// double angle identity
    float Cosri = VoL - pbrInputs.NdotV * pbrInputs.NdotL;
    float a2_13 = a2 + 1.36053;
    float Fr = ( 1 - ( 0.542026*a2 + 0.303573*a ) / a2_13 ) * ( 1 - pow( 1 - pbrInputs.NdotV, 5 - 4*a2 ) / a2_13 ) * ( ( -0.733996*a2*a + 1.50912*a2 - 1.16402*a ) * pow( 1 - pbrInputs.NdotV, 1 + rcp(39*a2*a2+1) ) + 1 );
    //float Fr = ( 1 - 0.36 * a ) * ( 1 - pow( 1 - NoV, 5 - 4*a2 ) / a2_13 ) * ( -2.5 * Roughness * ( 1 - NoV ) + 1 );
    float Lm = ( max( 1 - 2*a, 0 ) * ( 1 - pow5( 1 - pbrInputs.NdotL ) ) + min( 2*a, 1 ) ) * ( 1 - 0.5*a * (pbrInputs.NdotL - 1) ) * pbrInputs.NdotL;
    float Vd = ( a2 / ( (a2 + 0.09) * (1.31072 + 0.995584 * pbrInputs.NdotV) ) ) * ( 1 - pow( 1 - pbrInputs.NdotL, ( 1 - 0.3726732 * pbrInputs.NdotV * pbrInputs.NdotV ) / ( 0.188566 + 0.38841 * pbrInputs.NdotV ) ) );
    float Bp = Cosri < 0 ? 1.4 * pbrInputs.NdotV * pbrInputs.NdotL * Cosri : Cosri;
    float Lr = (21.0 / 20.0) * (1 - F0) * ( Fr * Lm + Vd + Bp );
    return pbrInputs.diffuseColor * RECIPROCAL_PI * Lr;
}

vec3 BRDF_Diffuse_Burley(PBRInfo pbrInputs)
{
    float energyBias = mix(pbrInputs.perceptualRoughness, 0.0, 0.5);
    float energyFactor = mix(pbrInputs.perceptualRoughness, 1.0, 1.0 / 1.51);
    float fd90 = energyBias + 2.0 * pbrInputs.VdotH * pbrInputs.VdotH * pbrInputs.perceptualRoughness;
    float f0 = 1.0;
    float lightScatter = f0 + (fd90 - f0) * pow(1.0 - pbrInputs.NdotL, 5.0);
    float viewScatter = f0 + (fd90 - f0) * pow(1.0 - pbrInputs.NdotV, 5.0);

    return pbrInputs.diffuseColor * lightScatter * viewScatter * energyFactor;
}

vec3 BRDF_Diffuse_Disney(PBRInfo pbrInputs)
{
	float Fd90 = 0.5 + 2.0 * pbrInputs.perceptualRoughness * pbrInputs.VdotH * pbrInputs.VdotH;
    vec3 f0 = vec3(0.1);
	vec3 invF0 = vec3(1.0, 1.0, 1.0) - f0;
	float dim = min(invF0.r, min(invF0.g, invF0.b));
	float result = ((1.0 + (Fd90 - 1.0) * pow(1.0 - pbrInputs.NdotL, 5.0 )) * (1.0 + (Fd90 - 1.0) * pow(1.0 - pbrInputs.NdotV, 5.0 ))) * dim;
	return pbrInputs.diffuseColor * result;
}

// The following equation models the Fresnel reflectance term of the spec equation (aka F())
// Implementation of fresnel from [4], Equation 15
vec3 specularReflection(PBRInfo pbrInputs)
{
    //return pbrInputs.reflectance0 + (pbrInputs.reflectance90 - pbrInputs.reflectance0) * pow(clamp(1.0 - pbrInputs.VdotH, 0.0, 1.0), 5.0);
    return pbrInputs.reflectance0 + (pbrInputs.reflectance90 - pbrInputs.reflectance90*pbrInputs.reflectance0) * exp2((-5.55473 * pbrInputs.VdotH - 6.98316) * pbrInputs.VdotH);
}

// This calculates the specular geometric attenuation (aka G()),
// where rougher material will reflect less light back to the viewer.
// This implementation is based on [1] Equation 4, and we adopt their modifications to
// alphaRoughness as input as originally proposed in [2].
float geometricOcclusion(PBRInfo pbrInputs)
{
    float NdotL = pbrInputs.NdotL;
    float NdotV = pbrInputs.NdotV;
    float r = pbrInputs.alphaRoughness * pbrInputs.alphaRoughness;

    float attenuationL = 2.0 * NdotL / (NdotL + sqrt(r + (1.0 - r) * (NdotL * NdotL)));
    float attenuationV = 2.0 * NdotV / (NdotV + sqrt(r + (1.0 - r) * (NdotV * NdotV)));
    return attenuationL * attenuationV;
}

// The following equation(s) model the distribution of microfacet normals across the area being drawn (aka D())
// Implementation from \"Average Irregularity Representation of a Roughened Surface for Ray Reflection\" by T. S. Trowbridge, and K. P. Reitz
// Follows the distribution function recommended in the SIGGRAPH 2013 course notes from EPIC Games [1], Equation 3.
float microfacetDistribution(PBRInfo pbrInputs)
{
    float roughnessSq = pbrInputs.alphaRoughness * pbrInputs.alphaRoughness;
    float f = (pbrInputs.NdotH * roughnessSq - pbrInputs.NdotH) * pbrInputs.NdotH + 1.0;
    return roughnessSq / (PI * f * f);
}

vec3 BRDF(vec3 v, vec3 n, vec3 l, vec3 h, float perceptualRoughness, float metallic, vec3 specularEnvironmentR0, vec3 specularEnvironmentR90, float alphaRoughness, vec3 diffuseColor, vec3 specularColor, float ao)
{
    vec3 reflection = -normalize(reflect(v, n));
    reflection.y *= -1.0f;

    float NdotL = clamp(dot(n, l), 0.001, 1.0);
    float NdotV = clamp(abs(dot(n, v)), 0.001, 1.0);
    float NdotH = clamp(dot(n, h), 0.0, 1.0);
    float LdotH = clamp(dot(l, h), 0.0, 1.0);
    float VdotH = clamp(dot(v, h), 0.0, 1.0);
    float VdotL = clamp(dot(v, l), 0.0, 1.0);

    PBRInfo pbrInputs = PBRInfo(NdotL,
                                NdotV,
                                NdotH,
                                LdotH,
                                VdotH,
                                VdotL,
                                perceptualRoughness,
                                metallic,
                                specularEnvironmentR0,
                                specularEnvironmentR90,
                                alphaRoughness,
                                diffuseColor,
                                specularColor);

    // Calculate the shading terms for the microfacet specular shading model
    vec3 F = specularReflection(pbrInputs);
    float G = geometricOcclusion(pbrInputs);
    float D = microfacetDistribution(pbrInputs);

    const vec3 u_LightColor = vec3(1.0);

    // Calculation of analytical lighting contribution
    vec3 diffuseContrib = (1.0 - F) * BRDF_Diffuse_Disney(pbrInputs);
    vec3 specContrib = F * G * D / (4.0 * NdotL * NdotV);
    // Obtain final intensity as reflectance (BRDF) scaled by the energy of the light (cosine law)
    vec3 color = NdotL * u_LightColor * (diffuseContrib + specContrib);

    color *= ao;

#ifdef VSG_EMISSIVE_MAP
    vec3 emissive = SRGBtoLINEAR(texture(emissiveMap, texCoord0)).rgb * pbr.emissiveFactor.rgb;
#else
    vec3 emissive = pbr.emissiveFactor.rgb;
#endif
    color += emissive;

    return color;
}

float convertMetallic(vec3 diffuse, vec3 specular, float maxSpecular)
{
    float perceivedDiffuse = sqrt(0.299 * diffuse.r * diffuse.r + 0.587 * diffuse.g * diffuse.g + 0.114 * diffuse.b * diffuse.b);
    float perceivedSpecular = sqrt(0.299 * specular.r * specular.r + 0.587 * specular.g * specular.g + 0.114 * specular.b * specular.b);

    if (perceivedSpecular < c_MinRoughness)
    {
        return 0.0;
    }

    float a = c_MinRoughness;
    float b = perceivedDiffuse * (1.0 - maxSpecular) / (1.0 - c_MinRoughness) + perceivedSpecular - 2.0 * c_MinRoughness;
    float c = c_MinRoughness - perceivedSpecular;
    float D = max(b * b - 4.0 * a * c, 0.0);
    return clamp((-b + sqrt(D)) / (2.0 * a), 0.0, 1.0);
}

void main()
{
    float perceptualRoughness = 0.0;
    float metallic;
    vec3 diffuseColor;
    vec4 baseColor;

    float ambientOcclusion = 1.0;

    vec3 f0 = vec3(0.04);

#ifdef VSG_DIFFUSE_MAP
    baseColor = SRGBtoLINEAR(texture(diffuseMap, texCoord0)) * pbr.baseColorFactor;
#else
    baseColor = pbr.baseColorFactor;
#endif

    if (pbr.alphaMask == 1.0f)
    {
        if (baseColor.a < pbr.alphaMaskCutoff)
            discard;
    }


#ifdef VSG_WORKFLOW_SPECGLOSS
    #ifdef VSG_SPECULAR_MAP
        vec3 specular = SRGBtoLINEAR(texture(specularMap, texCoord0)).rgb;
        perceptualRoughness = 1.0 - texture(specularMap, texCoord0).a;
    #else
        vec3 specular = vec3(0.0);
        perceptualRoughness = 0.0;
    #endif

        const float epsilon = 1e-6;

    #ifdef VSG_DIFFUSE_MAP
        vec4 diffuse = SRGBtoLINEAR(texture(diffuseMap, texCoord0));
    #else
        vec4 diffuse = vec4(1.0);
    #endif

        float maxSpecular = max(max(specular.r, specular.g), specular.b);

        // Convert metallic value from specular glossiness inputs
        metallic = convertMetallic(diffuse.rgb, specular, maxSpecular);

        vec3 baseColorDiffusePart = diffuse.rgb * ((1.0 - maxSpecular) / (1 - c_MinRoughness) / max(1 - metallic, epsilon)) * pbr.diffuseFactor.rgb;
        vec3 baseColorSpecularPart = specular - (vec3(c_MinRoughness) * (1 - metallic) * (1 / max(metallic, epsilon))) * pbr.specularFactor.rgb;
        baseColor = vec4(mix(baseColorDiffusePart, baseColorSpecularPart, metallic * metallic), diffuse.a);
#else
        perceptualRoughness = pbr.roughnessFactor;
        metallic = pbr.metallicFactor;

    #ifdef VSG_METALLROUGHNESS_MAP
        vec4 mrSample = texture(mrMap, texCoord0);
        perceptualRoughness = mrSample.g * perceptualRoughness;
        metallic = mrSample.b * metallic;
    #endif
#endif

#ifdef VSG_LIGHTMAP_MAP
    ambientOcclusion = texture(aoMap, texCoord0).r;
#endif

    diffuseColor = baseColor.rgb * (vec3(1.0) - f0);
    diffuseColor *= 1.0 - metallic;

    float alphaRoughness = perceptualRoughness * perceptualRoughness;

    vec3 specularColor = mix(f0, baseColor.rgb, metallic);

    // Compute reflectance.
    float reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);

    // For typical incident reflectance range (between 4% to 100%) set the grazing reflectance to 100% for typical fresnel effect.
    // For very low reflectance range on highly diffuse objects (below 4%), incrementally reduce grazing reflecance to 0%.
    float reflectance90 = clamp(reflectance * 25.0, 0.0, 1.0);
    vec3 specularEnvironmentR0 = specularColor.rgb;
    vec3 specularEnvironmentR90 = vec3(1.0, 1.0, 1.0) * reflectance90;

    vec3 n = getNormal();
    vec3 v = normalize(viewDir);    // Vector from surface point to camera
    vec3 l = normalize(lightDir);     // Vector from surface point to light
    vec3 h = normalize(l+v);                        // Half vector between both l and v

    vec3 colorFrontFace = BRDF(v, n, l, h, perceptualRoughness, metallic, specularEnvironmentR0, specularEnvironmentR90, alphaRoughness, diffuseColor, specularColor, ambientOcclusion);
#ifdef VSG_TWOSIDED
    vec3 colorBackFace = BRDF(v, -n, l, h, perceptualRoughness, metallic, specularEnvironmentR0, specularEnvironmentR90, alphaRoughness, diffuseColor, specularColor, ambientOcclusion);
    vec3 color = colorFrontFace+colorBackFace;
#else
    vec3 color = colorFrontFace;
#endif

    outColor = LINEARtoSRGB(vec4(color, baseColor.a));
}
"
                  SPIRVSize 0
                  SPIRV
                }
                NumSpecializationConstants 0
              }
              NumPipelineStates 6
              PipelineState id=19 vsg::VertexInputState
              {
                NumUserObjects 0
                NumBindings 3
                binding 0
                stride 12
                inputRate 0
                binding 1
                stride 12
                inputRate 0
                binding 2
                stride 8
                inputRate 0
                NumAttributes 3
                location 0
                binding 0
                format 106
                offset 0
                location 1
                binding 1
                format 106
                offset 0
                location 2
                binding 2
                format 103
                offset 0
              }
              PipelineState id=20 vsg::InputAssemblyState
              {
                NumUserObjects 0
                topology 3
                primitiveRestartEnable 0
              }
              PipelineState id=21 vsg::RasterizationState
              {
                NumUserObjects 0
                depthClampEnable 0
                rasterizerDiscardEnable 0
                polygonMode 0
                cullMode 0
                frontFace 0
                depthBiasEnable 0
                depthBiasConstantFactor 1
                depthBiasClamp 0
                depthBiasSlopeFactor 1
                lineWidth 1
              }
              PipelineState id=22 vsg::MultisampleState
              {
                NumUserObjects 0
                rasterizationSamples 1
                sampleShadingEnable 0
                minSampleShading 0
                NumSampleMask 0
                alphaToCoverageEnable 0
                alphaToOneEnable 0
              }
              PipelineState id=23 vsg::ColorBlendState
              {
                NumUserObjects 0
                logicOp 3
                logicOpEnable 0
                NumColorBlendAttachments 1
                blendEnable 0
                srcColorBlendFactor 6
                dstColorBlendFactor 7
                colorBlendOp 0
                srcAlphaBlendFactor 6
                dstAlphaBlendFactor 7
                alphaBlendOp 1
                colorWriteMask 15
                blendConstants 0 0 0 0
              }
              PipelineState id=24 vsg::DepthStencilState
              {
                NumUserObjects 0
                depthTestEnable 1
                depthWriteEnable 1
                depthCompareOp 1
                depthBoundsTestEnable 0
                stencilTestEnable 0
                front.failOp 0
                front.passOp 0
                front.depthFailOp 0
                front.compareOp 0
                front.compareMask 0
                front.writeMask 0
                front.reference 0
                back.failOp 0
                back.passOp 0
                back.depthFailOp 0
                back.compareOp 0
                back.compareMask 0
                back.writeMask 0
                back.reference 0
                minDepthBounds 0
                maxDepthBounds 1
              }
              subpass 0
            }
          }
          StateCommand id=25 vsg::BindDescriptorSet
          {
            NumUserObjects 0
            Slot 1
            PipelineLayout id=13
            firstSet 0
            DescriptorSet id=26 vsg::DescriptorSet
            {
              NumUserObjects 0
              DescriptorSetLayout id=14
              NumDescriptors 1
              Descriptor id=27 vsg::DescriptorBuffer
              {
                NumUserObjects 0
                DstBinding 10
                DstArrayElement 0
                NumData 1
                Data id=28 vsg::ubyteArray
                {
                  NumUserObjects 0
                  Layout 0 1 0 1 1 1 0 -1
                  Size 80
                  Storage id=0
                  Data 206 204 76 63 18 123 169 60 48 195 91 60
                   0 0 128 63 0 0 0 0 0 0 0 0
                   0 0 0 0 0 0 128 63 0 0 128 63
                   0 0 128 63 0 0 128 63 0 0 128 63
                   0 0 0 0 0 0 0 0 0 0 0 0
                   0 0 128 63 0 0 0 0 0 0 0 0
                   0 0 128 63 0 0 0 63
                }
              }
            }
          }
        }
        Matrix -0.8 -2.54292e-08 2.54292e-08 0 2.54292e-08 -9.53674e-08 0.8 0 -9.17563e-08 2.88664 1.72057e-07 0
         1.78077 -2 1.3531 1
        SubgraphRequiresLocalFrustum 1
      }
      Child id=29 vsg::MatrixTransform
      {
        NumUserObjects 0
        NumChildren 0
        Matrix 0.147601 0.189246 0 0 -0.189246 0.147601 0 0 0 0 0.236654 0
         0.968529 0 0.49093 1
        SubgraphRequiresLocalFrustum 1
      }
      Child id=30 vsg::MatrixTransform
      {
        NumUserObjects 0
        NumChildren 0
        Matrix -0.290865 0.955171 -0.0551891 0 -0.771101 -0.199883 0.604525 0 0.566393 0.218391 0.794672 0
         0 0 5.90386 1
        SubgraphRequiresLocalFrustum 1
      }
      Child id=31 vsg::MatrixTransform
      {
        NumUserObjects 0
        NumChildren 1
        Child id=32 vsg::StateGroup
        {
          NumUserObjects 0
          NumChildren 1
          Child id=33 vsg::VertexIndexDraw
          {
            NumUserObjects 0
            firstBinding 0
            NumArrays 3
            Array id=34 vsg::vec3Array
            {
              NumUserObjects 0
              Layout 0 12 0 1 1 1 0 -1
              Size 24
              Storage id=0
              Data 1 1 1 1 1 1 1 1 1 1 1 -1
               1 1 -1 1 1 -1 1 -1 1 1 -1 1
               1 -1 1 1 -1 -1 1 -1 -1 1 -1 -1
               -1 1 1 -1 1 1 -1 1 1 -1 1 -1
               -1 1 -1 -1 1 -1 -1 -1 1 -1 -1 1
               -1 -1 1 -1 -1 -1 -1 -1 -1 -1 -1 -1
            }
            Array id=35 vsg::vec3Array
            {
              NumUserObjects 0
              Layout 0 12 0 1 1 1 0 -1
              Size 24
              Storage id=0
              Data 0 0 1 0 1 0 1 0 0 0 0 -1
               0 1 0 1 0 0 0 -1 0 0 0 1
               1 0 0 0 -1 0 0 0 -1 1 0 0
               -1 0 0 0 0 1 0 1 0 -1 0 0
               0 0 -1 0 1 0 -1 0 0 0 -1 0
               0 0 1 -1 0 0 0 -1 0 0 0 -1
            }
            Array id=36 vsg::vec2Array
            {
              NumUserObjects 0
              Layout 0 8 0 1 1 1 0 -1
              Size 24
              Storage id=0
              Data 0.625 0.5 0.625 0.5 0.625 0.5 0.375 0.5 0.375 0.5 0.375 0.5
               0.625 0.25 0.625 0.25 0.625 0.25 0.375 0.25 0.375 0.25 0.375 0.25
               0.625 0.75 0.875 0.5 0.625 0.75 0.375 0.75 0.125 0.5 0.375 0.75
               0.625 1 0.625 0 0.875 0.25 0.375 1 0.375 0 0.125 0.25
            }
            Indices id=37 vsg::ushortArray
            {
              NumUserObjects 0
              Layout 0 2 0 1 1 1 0 -1
              Size 36
              Storage id=0
              Data 0 13 20 0 20 7 5 2 8 5 8 11
               16 3 10 16 10 23 17 1 4 17 14 1
               9 6 19 9 19 22 21 18 12 21 12 15
            }
            indexCount 36
            instanceCount 1
            firstIndex 0
            vertexOffset 0
            firstInstance 0
          }
          NumStateCommands 2
          StateCommand id=38 vsg::BindGraphicsPipeline
          {
            NumUserObjects 0
            Slot 0
            GraphicsPipeline id=39 vsg::GraphicsPipeline
            {
              NumUserObjects 0
              PipelineLayout id=40 vsg::PipelineLayout
              {
                NumUserObjects 0
                Flags 0
                NumDescriptorSetLayouts 1
                DescriptorSetLayout id=41 vsg::DescriptorSetLayout
                {
                  NumUserObjects 0
                  NumDescriptorSetLayoutBindings 1
                  binding 10
                  descriptorType 6
                  descriptorCount 1
                  stageFlags 16
                }
                NumPushConstantRanges 1
                stageFlags 1
                offset 0
                size 128
              }
              NumShaderStages 2
              ShaderStage id=42 vsg::ShaderStage
              {
                NumUserObjects 0
                Stage 1
                EntryPoint "main"
                ShaderModule id=43 vsg::ShaderModule
                {
                  NumUserObjects 0
                  Source "#version 450

#extension GL_ARB_separate_shader_objects : enable

layout(push_constant) uniform PushConstants {
    mat4 projection;
    mat4 modelView;
} pc;

layout(location = 0) in vec3 osg_Vertex;
layout(location = 0) out vec3 worldPos;

layout(location = 1) in vec3 osg_Normal;
layout(location = 1) out vec3 normalDir;

layout(location = 2) in vec2 osg_TexCoord0;
layout(location = 2) out vec2 texCoord0;

layout(location = 5) out vec3 viewDir;
layout(location = 6) out vec3 lightDir;

out gl_PerVertex{ vec4 gl_Position; };

void main()
{
    gl_Position = (pc.projection * pc.modelView) * vec4(osg_Vertex, 1.0);
    worldPos = vec4(pc.modelView * vec4(osg_Vertex, 1.0)).xyz;

    vec3 n = (pc.modelView * vec4(osg_Normal, 0.0)).xyz;
    normalDir = n;
    vec4 lpos = /*osg_LightSource.position*/ vec4(0.0, 0.25, 1.0, 0.0);
    viewDir = -vec3(pc.modelView * vec4(osg_Vertex, 1.0));

    if (lpos.w == 0.0)
        lightDir = lpos.xyz;
    else
        lightDir = lpos.xyz + viewDir;

    texCoord0 = osg_TexCoord0 * vec2(1,1);
}
"
                  SPIRVSize 0
                  SPIRV
                }
                NumSpecializationConstants 0
              }
              ShaderStage id=44 vsg::ShaderStage
              {
                NumUserObjects 0
                Stage 16
                EntryPoint "main"
                ShaderModule id=45 vsg::ShaderModule
                {
                  NumUserObjects 0
                  Source "#version 450
#pragma import_defines (VSG_DIFFUSE_MAP, VSG_EMISSIVE_MAP, VSG_LIGHTMAP_MAP, VSG_NORMAL_MAP, VSG_METALLROUGHNESS_MAP, VSG_SPECULAR_MAP, VSG_TWOSIDED, VSG_WORKFLOW_SPECGLOSS)
#define VSG_TWOSIDED

#extension GL_ARB_separate_shader_objects : enable

const float PI = 3.14159265359;
const float RECIPROCAL_PI = 0.31830988618;
const float RECIPROCAL_PI2 = 0.15915494;
const float EPSILON = 1e-6;
const float c_MinRoughness = 0.04;

#ifdef VSG_DIFFUSE_MAP
layout(binding = 0) uniform sampler2D diffuseMap;
#endif

#ifdef VSG_METALLROUGHNESS_MAP
layout(binding = 1) uniform sampler2D mrMap;
#endif

#ifdef VSG_NORMAL_MAP
layout(binding = 2) uniform sampler2D normalMap;
#endif

#ifdef VSG_LIGHTMAP_MAP
layout(binding = 3) uniform sampler2D aoMap;
#endif

#ifdef VSG_EMISSIVE_MAP
layout(binding = 4) uniform sampler2D emissiveMap;
#endif

#ifdef VSG_SPECULAR_MAP
layout(binding = 5) uniform sampler2D specularMap;
#endif

layout(push_constant) uniform PushConstants {
    mat4 projection;
    mat4 modelView;
} pc;

layout(binding = 10) uniform PbrData
{
    vec4 baseColorFactor;
    vec4 emissiveFactor;
    vec4 diffuseFactor;
    vec4 specularFactor;
    float metallicFactor;
    float roughnessFactor;
    float alphaMask;
    float alphaMaskCutoff;
} pbr;

layout(location = 0) in vec3 worldPos;
layout(location = 1) in vec3 normalDir;
layout(location = 2) in vec2 texCoord0;
layout(location = 5) in vec3 viewDir;
layout(location = 6) in vec3 lightDir;

layout(location = 0) out vec4 outColor;


// Encapsulate the various inputs used by the various functions in the shading equation
// We store values in this struct to simplify the integration of alternative implementations
// of the shading terms, outlined in the Readme.MD Appendix.
struct PBRInfo
{
    float NdotL;                  // cos angle between normal and light direction
    float NdotV;                  // cos angle between normal and view direction
    float NdotH;                  // cos angle between normal and half vector
    float LdotH;                  // cos angle between light direction and half vector
    float VdotH;                  // cos angle between view direction and half vector
    float VdotL;                  // cos angle between view direction and light direction
    float perceptualRoughness;    // roughness value, as authored by the model creator (input to shader)
    float metalness;              // metallic value at the surface
    vec3 reflectance0;            // full reflectance color (normal incidence angle)
    vec3 reflectance90;           // reflectance color at grazing angle
    float alphaRoughness;         // roughness mapped to a more linear change in the roughness (proposed by [2])
    vec3 diffuseColor;            // color contribution from diffuse lighting
    vec3 specularColor;           // color contribution from specular lighting
};


vec4 SRGBtoLINEAR(vec4 srgbIn)
{
    vec3 linOut = pow(srgbIn.xyz, vec3(2.2));
    return vec4(linOut,srgbIn.w);
}

vec4 LINEARtoSRGB(vec4 srgbIn)
{
    vec3 linOut = pow(srgbIn.xyz, vec3(1.0 / 2.2));
    return vec4(linOut, srgbIn.w);
}

float rcp(const in float value)
{
    return 1.0 / value;
}

float pow5(const in float value)
{
    return value * value * value * value * value;
}

// Find the normal for this fragment, pulling either from a predefined normal map
// or from the interpolated mesh normal and tangent attributes.
vec3 getNormal()
{
#ifdef VSG_NORMAL_MAP
    // Perturb normal, see http://www.thetenthplanet.de/archives/1180
    vec3 tangentNormal = texture(normalMap, texCoord0).xyz * 2.0 - 1.0;

    //tangentNormal *= vec3(2,2,1);

    vec3 q1 = dFdx(worldPos);
    vec3 q2 = dFdy(worldPos);
    vec2 st1 = dFdx(texCoord0);
    vec2 st2 = dFdy(texCoord0);

    vec3 N = normalize(normalDir);
    vec3 T = normalize(q1 * st2.t - q2 * st1.t);
    vec3 B = -normalize(cross(N, T));
    mat3 TBN = mat3(T, B, N);

    return normalize(TBN * tangentNormal);
#else
    return normalize(normalDir);
#endif
}

// Basic Lambertian diffuse
// Implementation from Lambert's Photometria https://archive.org/details/lambertsphotome00lambgoog
// See also [1], Equation 1
vec3 BRDF_Diffuse_Lambert(PBRInfo pbrInputs)
{
    return pbrInputs.diffuseColor * RECIPROCAL_PI;
}

vec3 BRDF_Diffuse_Custom_Lambert(PBRInfo pbrInputs)
{
    return pbrInputs.diffuseColor * RECIPROCAL_PI * pow(pbrInputs.NdotV, 0.5 + 0.3 * pbrInputs.perceptualRoughness);
}

// [Gotanda 2012, \"Beyond a Simple Physically Based Blinn-Phong Model in Real-Time\"]
vec3 BRDF_Diffuse_OrenNayar(PBRInfo pbrInputs)
{
    float a = pbrInputs.alphaRoughness;
    float s = a;// / ( 1.29 + 0.5 * a );
    float s2 = s * s;
    float VoL = 2 * pbrInputs.VdotH * pbrInputs.VdotH - 1;		// double angle identity
    float Cosri = pbrInputs.VdotL - pbrInputs.NdotV * pbrInputs.NdotL;
    float C1 = 1 - 0.5 * s2 / (s2 + 0.33);
    float C2 = 0.45 * s2 / (s2 + 0.09) * Cosri * ( Cosri >= 0 ? 1.0 / max(pbrInputs.NdotL, pbrInputs.NdotV) : 1 );
    return pbrInputs.diffuseColor / PI * ( C1 + C2 ) * ( 1 + pbrInputs.perceptualRoughness * 0.5 );
}

// [Gotanda 2014, \"Designing Reflectance Models for New Consoles\"]
vec3 BRDF_Diffuse_Gotanda(PBRInfo pbrInputs)
{
    float a = pbrInputs.alphaRoughness;
    float a2 = a * a;
    float F0 = 0.04;
    float VoL = 2 * pbrInputs.VdotH * pbrInputs.VdotH - 1;		// double angle identity
    float Cosri = VoL - pbrInputs.NdotV * pbrInputs.NdotL;
    float a2_13 = a2 + 1.36053;
    float Fr = ( 1 - ( 0.542026*a2 + 0.303573*a ) / a2_13 ) * ( 1 - pow( 1 - pbrInputs.NdotV, 5 - 4*a2 ) / a2_13 ) * ( ( -0.733996*a2*a + 1.50912*a2 - 1.16402*a ) * pow( 1 - pbrInputs.NdotV, 1 + rcp(39*a2*a2+1) ) + 1 );
    //float Fr = ( 1 - 0.36 * a ) * ( 1 - pow( 1 - NoV, 5 - 4*a2 ) / a2_13 ) * ( -2.5 * Roughness * ( 1 - NoV ) + 1 );
    float Lm = ( max( 1 - 2*a, 0 ) * ( 1 - pow5( 1 - pbrInputs.NdotL ) ) + min( 2*a, 1 ) ) * ( 1 - 0.5*a * (pbrInputs.NdotL - 1) ) * pbrInputs.NdotL;
    float Vd = ( a2 / ( (a2 + 0.09) * (1.31072 + 0.995584 * pbrInputs.NdotV) ) ) * ( 1 - pow( 1 - pbrInputs.NdotL, ( 1 - 0.3726732 * pbrInputs.NdotV * pbrInputs.NdotV ) / ( 0.188566 + 0.38841 * pbrInputs.NdotV ) ) );
    float Bp = Cosri < 0 ? 1.4 * pbrInputs.NdotV * pbrInputs.NdotL * Cosri : Cosri;
    float Lr = (21.0 / 20.0) * (1 - F0) * ( Fr * Lm + Vd + Bp );
    return pbrInputs.diffuseColor * RECIPROCAL_PI * Lr;
}

vec3 BRDF_Diffuse_Burley(PBRInfo pbrInputs)
{
    float energyBias = mix(pbrInputs.perceptualRoughness, 0.0, 0.5);
    float energyFactor = mix(pbrInputs.perceptualRoughness, 1.0, 1.0 / 1.51);
    float fd90 = energyBias + 2.0 * pbrInputs.VdotH * pbrInputs.VdotH * pbrInputs.perceptualRoughness;
    float f0 = 1.0;
    float lightScatter = f0 + (fd90 - f0) * pow(1.0 - pbrInputs.NdotL, 5.0);
    float viewScatter = f0 + (fd90 - f0) * pow(1.0 - pbrInputs.NdotV, 5.0);

    return pbrInputs.diffuseColor * lightScatter * viewScatter * energyFactor;
}

vec3 BRDF_Diffuse_Disney(PBRInfo pbrInputs)
{
	float Fd90 = 0.5 + 2.0 * pbrInputs.perceptualRoughness * pbrInputs.VdotH * pbrInputs.VdotH;
    vec3 f0 = vec3(0.1);
	vec3 invF0 = vec3(1.0, 1.0, 1.0) - f0;
	float dim = min(invF0.r, min(invF0.g, invF0.b));
	float result = ((1.0 + (Fd90 - 1.0) * pow(1.0 - pbrInputs.NdotL, 5.0 )) * (1.0 + (Fd90 - 1.0) * pow(1.0 - pbrInputs.NdotV, 5.0 ))) * dim;
	return pbrInputs.diffuseColor * result;
}

// The following equation models the Fresnel reflectance term of the spec equation (aka F())
// Implementation of fresnel from [4], Equation 15
vec3 specularReflection(PBRInfo pbrInputs)
{
    //return pbrInputs.reflectance0 + (pbrInputs.reflectance90 - pbrInputs.reflectance0) * pow(clamp(1.0 - pbrInputs.VdotH, 0.0, 1.0), 5.0);
    return pbrInputs.reflectance0 + (pbrInputs.reflectance90 - pbrInputs.reflectance90*pbrInputs.reflectance0) * exp2((-5.55473 * pbrInputs.VdotH - 6.98316) * pbrInputs.VdotH);
}

// This calculates the specular geometric attenuation (aka G()),
// where rougher material will reflect less light back to the viewer.
// This implementation is based on [1] Equation 4, and we adopt their modifications to
// alphaRoughness as input as originally proposed in [2].
float geometricOcclusion(PBRInfo pbrInputs)
{
    float NdotL = pbrInputs.NdotL;
    float NdotV = pbrInputs.NdotV;
    float r = pbrInputs.alphaRoughness * pbrInputs.alphaRoughness;

    float attenuationL = 2.0 * NdotL / (NdotL + sqrt(r + (1.0 - r) * (NdotL * NdotL)));
    float attenuationV = 2.0 * NdotV / (NdotV + sqrt(r + (1.0 - r) * (NdotV * NdotV)));
    return attenuationL * attenuationV;
}

// The following equation(s) model the distribution of microfacet normals across the area being drawn (aka D())
// Implementation from \"Average Irregularity Representation of a Roughened Surface for Ray Reflection\" by T. S. Trowbridge, and K. P. Reitz
// Follows the distribution function recommended in the SIGGRAPH 2013 course notes from EPIC Games [1], Equation 3.
float microfacetDistribution(PBRInfo pbrInputs)
{
    float roughnessSq = pbrInputs.alphaRoughness * pbrInputs.alphaRoughness;
    float f = (pbrInputs.NdotH * roughnessSq - pbrInputs.NdotH) * pbrInputs.NdotH + 1.0;
    return roughnessSq / (PI * f * f);
}

vec3 BRDF(vec3 v, vec3 n, vec3 l, vec3 h, float perceptualRoughness, float metallic, vec3 specularEnvironmentR0, vec3 specularEnvironmentR90, float alphaRoughness, vec3 diffuseColor, vec3 specularColor, float ao)
{
    vec3 reflection = -normalize(reflect(v, n));
    reflection.y *= -1.0f;

    float NdotL = clamp(dot(n, l), 0.001, 1.0);
    float NdotV = clamp(abs(dot(n, v)), 0.001, 1.0);
    float NdotH = clamp(dot(n, h), 0.0, 1.0);
    float LdotH = clamp(dot(l, h), 0.0, 1.0);
    float VdotH = clamp(dot(v, h), 0.0, 1.0);
    float VdotL = clamp(dot(v, l), 0.0, 1.0);

    PBRInfo pbrInputs = PBRInfo(NdotL,
                                NdotV,
                                NdotH,
                                LdotH,
                                VdotH,
                                VdotL,
                                perceptualRoughness,
                                metallic,
                                specularEnvironmentR0,
                                specularEnvironmentR90,
                                alphaRoughness,
                                diffuseColor,
                                specularColor);

    // Calculate the shading terms for the microfacet specular shading model
    vec3 F = specularReflection(pbrInputs);
    float G = geometricOcclusion(pbrInputs);
    float D = microfacetDistribution(pbrInputs);

    const vec3 u_LightColor = vec3(1.0);

    // Calculation of analytical lighting contribution
    vec3 diffuseContrib = (1.0 - F) * BRDF_Diffuse_Disney(pbrInputs);
    vec3 specContrib = F * G * D / (4.0 * NdotL * NdotV);
    // Obtain final intensity as reflectance (BRDF) scaled by the energy of the light (cosine law)
    vec3 color = NdotL * u_LightColor * (diffuseContrib + specContrib);

    color *= ao;

#ifdef VSG_EMISSIVE_MAP
    vec3 emissive = SRGBtoLINEAR(texture(emissiveMap, texCoord0)).rgb * pbr.emissiveFactor.rgb;
#else
    vec3 emissive = pbr.emissiveFactor.rgb;
#endif
    color += emissive;

    return color;
}

float convertMetallic(vec3 diffuse, vec3 specular, float maxSpecular)
{
    float perceivedDiffuse = sqrt(0.299 * diffuse.r * diffuse.r + 0.587 * diffuse.g * diffuse.g + 0.114 * diffuse.b * diffuse.b);
    float perceivedSpecular = sqrt(0.299 * specular.r * specular.r + 0.587 * specular.g * specular.g + 0.114 * specular.b * specular.b);

    if (perceivedSpecular < c_MinRoughness)
    {
        return 0.0;
    }

    float a = c_MinRoughness;
    float b = perceivedDiffuse * (1.0 - maxSpecular) / (1.0 - c_MinRoughness) + perceivedSpecular - 2.0 * c_MinRoughness;
    float c = c_MinRoughness - perceivedSpecular;
    float D = max(b * b - 4.0 * a * c, 0.0);
    return clamp((-b + sqrt(D)) / (2.0 * a), 0.0, 1.0);
}

void main()
{
    float perceptualRoughness = 0.0;
    float metallic;
    vec3 diffuseColor;
    vec4 baseColor;

    float ambientOcclusion = 1.0;

    vec3 f0 = vec3(0.04);

#ifdef VSG_DIFFUSE_MAP
    baseColor = SRGBtoLINEAR(texture(diffuseMap, texCoord0)) * pbr.baseColorFactor;
#else
    baseColor = pbr.baseColorFactor;
#endif

    if (pbr.alphaMask == 1.0f)
    {
        if (baseColor.a < pbr.alphaMaskCutoff)
            discard;
    }


#ifdef VSG_WORKFLOW_SPECGLOSS
    #ifdef VSG_SPECULAR_MAP
        vec3 specular = SRGBtoLINEAR(texture(specularMap, texCoord0)).rgb;
        perceptualRoughness = 1.0 - texture(specularMap, texCoord0).a;
    #else
        vec3 specular = vec3(0.0);
        perceptualRoughness = 0.0;
    #endif

        const float epsilon = 1e-6;

    #ifdef VSG_DIFFUSE_MAP
        vec4 diffuse = SRGBtoLINEAR(texture(diffuseMap, texCoord0));
    #else
        vec4 diffuse = vec4(1.0);
    #endif

        float maxSpecular = max(max(specular.r, specular.g), specular.b);

        // Convert metallic value from specular glossiness inputs
        metallic = convertMetallic(diffuse.rgb, specular, maxSpecular);

        vec3 baseColorDiffusePart = diffuse.rgb * ((1.0 - maxSpecular) / (1 - c_MinRoughness) / max(1 - metallic, epsilon)) * pbr.diffuseFactor.rgb;
        vec3 baseColorSpecularPart = specular - (vec3(c_MinRoughness) * (1 - metallic) * (1 / max(metallic, epsilon))) * pbr.specularFactor.rgb;
        baseColor = vec4(mix(baseColorDiffusePart, baseColorSpecularPart, metallic * metallic), diffuse.a);
#else
        perceptualRoughness = pbr.roughnessFactor;
        metallic = pbr.metallicFactor;

    #ifdef VSG_METALLROUGHNESS_MAP
        vec4 mrSample = texture(mrMap, texCoord0);
        perceptualRoughness = mrSample.g * perceptualRoughness;
        metallic = mrSample.b * metallic;
    #endif
#endif

#ifdef VSG_LIGHTMAP_MAP
    ambientOcclusion = texture(aoMap, texCoord0).r;
#endif

    diffuseColor = baseColor.rgb * (vec3(1.0) - f0);
    diffuseColor *= 1.0 - metallic;

    float alphaRoughness = perceptualRoughness * perceptualRoughness;

    vec3 specularColor = mix(f0, baseColor.rgb, metallic);

    // Compute reflectance.
    float reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);

    // For typical incident reflectance range (between 4% to 100%) set the grazing reflectance to 100% for typical fresnel effect.
    // For very low reflectance range on highly diffuse objects (below 4%), incrementally reduce grazing reflecance to 0%.
    float reflectance90 = clamp(reflectance * 25.0, 0.0, 1.0);
    vec3 specularEnvironmentR0 = specularColor.rgb;
    vec3 specularEnvironmentR90 = vec3(1.0, 1.0, 1.0) * reflectance90;

    vec3 n = getNormal();
    vec3 v = normalize(viewDir);    // Vector from surface point to camera
    vec3 l = normalize(lightDir);     // Vector from surface point to light
    vec3 h = normalize(l+v);                        // Half vector between both l and v

    vec3 colorFrontFace = BRDF(v, n, l, h, perceptualRoughness, metallic, specularEnvironmentR0, specularEnvironmentR90, alphaRoughness, diffuseColor, specularColor, ambientOcclusion);
#ifdef VSG_TWOSIDED
    vec3 colorBackFace = BRDF(v, -n, l, h, perceptualRoughness, metallic, specularEnvironmentR0, specularEnvironmentR90, alphaRoughness, diffuseColor, specularColor, ambientOcclusion);
    vec3 color = colorFrontFace+colorBackFace;
#else
    vec3 color = colorFrontFace;
#endif

    outColor = LINEARtoSRGB(vec4(color, baseColor.a));
}
"
                  SPIRVSize 0
                  SPIRV
                }
                NumSpecializationConstants 0
              }
              NumPipelineStates 6
              PipelineState id=46 vsg::VertexInputState
              {
                NumUserObjects 0
                NumBindings 3
                binding 0
                stride 12
                inputRate 0
                binding 1
                stride 12
                inputRate 0
                binding 2
                stride 8
                inputRate 0
                NumAttributes 3
                location 0
                binding 0
                format 106
                offset 0
                location 1
                binding 1
                format 106
                offset 0
                location 2
                binding 2
                format 103
                offset 0
              }
              PipelineState id=47 vsg::InputAssemblyState
              {
                NumUserObjects 0
                topology 3
                primitiveRestartEnable 0
              }
              PipelineState id=48 vsg::RasterizationState
              {
                NumUserObjects 0
                depthClampEnable 0
                rasterizerDiscardEnable 0
                polygonMode 0
                cullMode 0
                frontFace 0
                depthBiasEnable 0
                depthBiasConstantFactor 1
                depthBiasClamp 0
                depthBiasSlopeFactor 1
                lineWidth 1
              }
              PipelineState id=49 vsg::MultisampleState
              {
                NumUserObjects 0
                rasterizationSamples 1
                sampleShadingEnable 0
                minSampleShading 0
                NumSampleMask 0
                alphaToCoverageEnable 0
                alphaToOneEnable 0
              }
              PipelineState id=50 vsg::ColorBlendState
              {
                NumUserObjects 0
                logicOp 3
                logicOpEnable 0
                NumColorBlendAttachments 1
                blendEnable 0
                srcColorBlendFactor 6
                dstColorBlendFactor 7
                colorBlendOp 0
                srcAlphaBlendFactor 6
                dstAlphaBlendFactor 7
                alphaBlendOp 1
                colorWriteMask 15
                blendConstants 0 0 0 0
              }
              PipelineState id=51 vsg::DepthStencilState
              {
                NumUserObjects 0
                depthTestEnable 1
                depthWriteEnable 1
                depthCompareOp 1
                depthBoundsTestEnable 0
                stencilTestEnable 0
                front.failOp 0
                front.passOp 0
                front.depthFailOp 0
                front.compareOp 0
                front.compareMask 0
                front.writeMask 0
                front.reference 0
                back.failOp 0
                back.passOp 0
                back.depthFailOp 0
                back.compareOp 0
                back.compareMask 0
                back.writeMask 0
                back.reference 0
                minDepthBounds 0
                maxDepthBounds 1
              }
              subpass 0
            }
          }
          StateCommand id=52 vsg::BindDescriptorSet
          {
            NumUserObjects 0
            Slot 1
            PipelineLayout id=40
            firstSet 0
            DescriptorSet id=53 vsg::DescriptorSet
            {
              NumUserObjects 0
              DescriptorSetLayout id=41
              NumDescriptors 1
              Descriptor id=54 vsg::DescriptorBuffer
              {
                NumUserObjects 0
                DstBinding 10
                DstArrayElement 0
                NumData 1
                Data id=55 vsg::ubyteArray
                {
                  NumUserObjects 0
                  Layout 0 1 0 1 1 1 0 -1
                  Size 80
                  Storage id=0
                  Data 0 0 0 0 0 0 0 0 0 0 0 0
                   0 0 128 63 0 0 0 0 0 0 0 0
                   0 0 0 0 0 0 128 63 0 0 128 63
                   0 0 128 63 0 0 128 63 0 0 128 63
                   0 0 0 0 0 0 0 0 0 0 0 0
                   0 0 128 63 0 0 0 0 205 204 204 62
                   0 0 128 63 0 0 0 63
                }
              }
            }
          }
        }
        Matrix 0.1 0 0 0 0 0.1 0 0 0 0 1.5 0
         -2 1 1.5 1
        SubgraphRequiresLocalFrustum 1
      }
      Child id=56 vsg::MatrixTransform
      {
        NumUserObjects 0
        NumChildren 1
        Child id=57 vsg::StateGroup
        {
          NumUserObjects 0
          NumChildren 1
          Child id=58 vsg::VertexIndexDraw
          {
            NumUserObjects 0
            firstBinding 0
            NumArrays 3
            Array id=59 vsg::vec3Array
            {
              NumUserObjects 0
              Layout 0 12 0 1 1 1 0 -1
              Size 24
              Storage id=0
              Data 1 1 1 1 1 1 1 1 1 1 1 -1
               1 1 -1 1 1 -1 1 -1 1 1 -1 1
               1 -1 1 1 -1 -1 1 -1 -1 1 -1 -1
               -1 1 1 -1 1 1 -1 1 1 -1 1 -1
               -1 1 -1 -1 1 -1 -1 -1 1 -1 -1 1
               -1 -1 1 -1 -1 -1 -1 -1 -1 -1 -1 -1
            }
            Array id=60 vsg::vec3Array
            {
              NumUserObjects 0
              Layout 0 12 0 1 1 1 0 -1
              Size 24
              Storage id=0
              Data 0 0 1 0 1 0 1 0 0 0 0 -1
               0 1 0 1 0 0 0 -1 0 0 0 1
               1 0 0 0 -1 0 0 0 -1 1 0 0
               -1 0 0 0 0 1 0 1 0 -1 0 0
               0 0 -1 0 1 0 -1 0 0 0 -1 0
               0 0 1 -1 0 0 0 -1 0 0 0 -1
            }
            Array id=61 vsg::vec2Array
            {
              NumUserObjects 0
              Layout 0 8 0 1 1 1 0 -1
              Size 24
              Storage id=0
              Data 0.625 0.5 0.625 0.5 0.625 0.5 0.375 0.5 0.375 0.5 0.375 0.5
               0.625 0.25 0.625 0.25 0.625 0.25 0.375 0.25 0.375 0.25 0.375 0.25
               0.625 0.75 0.875 0.5 0.625 0.75 0.375 0.75 0.125 0.5 0.375 0.75
               0.625 1 0.625 0 0.875 0.25 0.375 1 0.375 0 0.125 0.25
            }
            Indices id=62 vsg::ushortArray
            {
              NumUserObjects 0
              Layout 0 2 0 1 1 1 0 -1
              Size 36
              Storage id=0
              Data 0 13 20 0 20 7 5 2 8 5 8 11
               16 3 10 16 10 23 17 1 4 17 14 1
               9 6 19 9 19 22 21 18 12 21 12 15
            }
            indexCount 36
            instanceCount 1
            firstIndex 0
            vertexOffset 0
            firstInstance 0
          }
          NumStateCommands 2
          StateCommand id=63 vsg::BindGraphicsPipeline
          {
            NumUserObjects 0
            Slot 0
            GraphicsPipeline id=64 vsg::GraphicsPipeline
            {
              NumUserObjects 0
              PipelineLayout id=65 vsg::PipelineLayout
              {
                NumUserObjects 0
                Flags 0
                NumDescriptorSetLayouts 1
                DescriptorSetLayout id=66 vsg::DescriptorSetLayout
                {
                  NumUserObjects 0
                  NumDescriptorSetLayoutBindings 1
                  binding 10
                  descriptorType 6
                  descriptorCount 1
                  stageFlags 16
                }
                NumPushConstantRanges 1
                stageFlags 1
                offset 0
                size 128
              }
              NumShaderStages 2
              ShaderStage id=67 vsg::ShaderStage
              {
                NumUserObjects 0
                Stage 1
                EntryPoint "main"
                ShaderModule id=68 vsg::ShaderModule
                {
                  NumUserObjects 0
                  Source "#version 450

#extension GL_ARB_separate_shader_objects : enable

layout(push_constant) uniform PushConstants {
    mat4 projection;
    mat4 modelView;
} pc;

layout(location = 0) in vec3 osg_Vertex;
layout(location = 0) out vec3 worldPos;

layout(location = 1) in vec3 osg_Normal;
layout(location = 1) out vec3 normalDir;

layout(location = 2) in vec2 osg_TexCoord0;
layout(location = 2) out vec2 texCoord0;

layout(location = 5) out vec3 viewDir;
layout(location = 6) out vec3 lightDir;

out gl_PerVertex{ vec4 gl_Position; };

void main()
{
    gl_Position = (pc.projection * pc.modelView) * vec4(osg_Vertex, 1.0);
    worldPos = vec4(pc.modelView * vec4(osg_Vertex, 1.0)).xyz;

    vec3 n = (pc.modelView * vec4(osg_Normal, 0.0)).xyz;
    normalDir = n;
    vec4 lpos = /*osg_LightSource.position*/ vec4(0.0, 0.25, 1.0, 0.0);
    viewDir = -vec3(pc.modelView * vec4(osg_Vertex, 1.0));

    if (lpos.w == 0.0)
        lightDir = lpos.xyz;
    else
        lightDir = lpos.xyz + viewDir;

    texCoord0 = osg_TexCoord0 * vec2(1,1);
}
"
                  SPIRVSize 0
                  SPIRV
                }
                NumSpecializationConstants 0
              }
              ShaderStage id=69 vsg::ShaderStage
              {
                NumUserObjects 0
                Stage 16
                EntryPoint "main"
                ShaderModule id=70 vsg::ShaderModule
                {
                  NumUserObjects 0
                  Source "#version 450
#pragma import_defines (VSG_DIFFUSE_MAP, VSG_EMISSIVE_MAP, VSG_LIGHTMAP_MAP, VSG_NORMAL_MAP, VSG_METALLROUGHNESS_MAP, VSG_SPECULAR_MAP, VSG_TWOSIDED, VSG_WORKFLOW_SPECGLOSS)
#define VSG_TWOSIDED

#extension GL_ARB_separate_shader_objects : enable

const float PI = 3.14159265359;
const float RECIPROCAL_PI = 0.31830988618;
const float RECIPROCAL_PI2 = 0.15915494;
const float EPSILON = 1e-6;
const float c_MinRoughness = 0.04;

#ifdef VSG_DIFFUSE_MAP
layout(binding = 0) uniform sampler2D diffuseMap;
#endif

#ifdef VSG_METALLROUGHNESS_MAP
layout(binding = 1) uniform sampler2D mrMap;
#endif

#ifdef VSG_NORMAL_MAP
layout(binding = 2) uniform sampler2D normalMap;
#endif

#ifdef VSG_LIGHTMAP_MAP
layout(binding = 3) uniform sampler2D aoMap;
#endif

#ifdef VSG_EMISSIVE_MAP
layout(binding = 4) uniform sampler2D emissiveMap;
#endif

#ifdef VSG_SPECULAR_MAP
layout(binding = 5) uniform sampler2D specularMap;
#endif

layout(push_constant) uniform PushConstants {
    mat4 projection;
    mat4 modelView;
} pc;

layout(binding = 10) uniform PbrData
{
    vec4 baseColorFactor;
    vec4 emissiveFactor;
    vec4 diffuseFactor;
    vec4 specularFactor;
    float metallicFactor;
    float roughnessFactor;
    float alphaMask;
    float alphaMaskCutoff;
} pbr;

layout(location = 0) in vec3 worldPos;
layout(location = 1) in vec3 normalDir;
layout(location = 2) in vec2 texCoord0;
layout(location = 5) in vec3 viewDir;
layout(location = 6) in vec3 lightDir;

layout(location = 0) out vec4 outColor;


// Encapsulate the various inputs used by the various functions in the shading equation
// We store values in this struct to simplify the integration of alternative implementations
// of the shading terms, outlined in the Readme.MD Appendix.
struct PBRInfo
{
    float NdotL;                  // cos angle between normal and light direction
    float NdotV;                  // cos angle between normal and view direction
    float NdotH;                  // cos angle between normal and half vector
    float LdotH;                  // cos angle between light direction and half vector
    float VdotH;                  // cos angle between view direction and half vector
    float VdotL;                  // cos angle between view direction and light direction
    float perceptualRoughness;    // roughness value, as authored by the model creator (input to shader)
    float metalness;              // metallic value at the surface
    vec3 reflectance0;            // full reflectance color (normal incidence angle)
    vec3 reflectance90;           // reflectance color at grazing angle
    float alphaRoughness;         // roughness mapped to a more linear change in the roughness (proposed by [2])
    vec3 diffuseColor;            // color contribution from diffuse lighting
    vec3 specularColor;           // color contribution from specular lighting
};


vec4 SRGBtoLINEAR(vec4 srgbIn)
{
    vec3 linOut = pow(srgbIn.xyz, vec3(2.2));
    return vec4(linOut,srgbIn.w);
}

vec4 LINEARtoSRGB(vec4 srgbIn)
{
    vec3 linOut = pow(srgbIn.xyz, vec3(1.0 / 2.2));
    return vec4(linOut, srgbIn.w);
}

float rcp(const in float value)
{
    return 1.0 / value;
}

float pow5(const in float value)
{
    return value * value * value * value * value;
}

// Find the normal for this fragment, pulling either from a predefined normal map
// or from the interpolated mesh normal and tangent attributes.
vec3 getNormal()
{
#ifdef VSG_NORMAL_MAP
    // Perturb normal, see http://www.thetenthplanet.de/archives/1180
    vec3 tangentNormal = texture(normalMap, texCoord0).xyz * 2.0 - 1.0;

    //tangentNormal *= vec3(2,2,1);

    vec3 q1 = dFdx(worldPos);
    vec3 q2 = dFdy(worldPos);
    vec2 st1 = dFdx(texCoord0);
    vec2 st2 = dFdy(texCoord0);

    vec3 N = normalize(normalDir);
    vec3 T = normalize(q1 * st2.t - q2 * st1.t);
    vec3 B = -normalize(cross(N, T));
    mat3 TBN = mat3(T, B, N);

    return normalize(TBN * tangentNormal);
#else
    return normalize(normalDir);
#endif
}

// Basic Lambertian diffuse
// Implementation from Lambert's Photometria https://archive.org/details/lambertsphotome00lambgoog
// See also [1], Equation 1
vec3 BRDF_Diffuse_Lambert(PBRInfo pbrInputs)
{
    return pbrInputs.diffuseColor * RECIPROCAL_PI;
}

vec3 BRDF_Diffuse_Custom_Lambert(PBRInfo pbrInputs)
{
    return pbrInputs.diffuseColor * RECIPROCAL_PI * pow(pbrInputs.NdotV, 0.5 + 0.3 * pbrInputs.perceptualRoughness);
}

// [Gotanda 2012, \"Beyond a Simple Physically Based Blinn-Phong Model in Real-Time\"]
vec3 BRDF_Diffuse_OrenNayar(PBRInfo pbrInputs)
{
    float a = pbrInputs.alphaRoughness;
    float s = a;// / ( 1.29 + 0.5 * a );
    float s2 = s * s;
    float VoL = 2 * pbrInputs.VdotH * pbrInputs.VdotH - 1;		// double angle identity
    float Cosri = pbrInputs.VdotL - pbrInputs.NdotV * pbrInputs.NdotL;
    float C1 = 1 - 0.5 * s2 / (s2 + 0.33);
    float C2 = 0.45 * s2 / (s2 + 0.09) * Cosri * ( Cosri >= 0 ? 1.0 / max(pbrInputs.NdotL, pbrInputs.NdotV) : 1 );
    return pbrInputs.diffuseColor / PI * ( C1 + C2 ) * ( 1 + pbrInputs.perceptualRoughness * 0.5 );
}

// [Gotanda 2014, \"Designing Reflectance Models for New Consoles\"]
vec3 BRDF_Diffuse_Gotanda(PBRInfo pbrInputs)
{
    float a = pbrInputs.alphaRoughness;
    float a2 = a * a;
    float F0 = 0.04;
    float VoL = 2 * pbrInputs.VdotH * pbrInputs.VdotH - 1;		// double angle identity
    float Cosri = VoL - pbrInputs.NdotV * pbrInputs.NdotL;
    float a2_13 = a2 + 1.36053;
    float Fr = ( 1 - ( 0.542026*a2 + 0.303573*a ) / a2_13 ) * ( 1 - pow( 1 - pbrInputs.NdotV, 5 - 4*a2 ) / a2_13 ) * ( ( -0.733996*a2*a + 1.50912*a2 - 1.16402*a ) * pow( 1 - pbrInputs.NdotV, 1 + rcp(39*a2*a2+1) ) + 1 );
    //float Fr = ( 1 - 0.36 * a ) * ( 1 - pow( 1 - NoV, 5 - 4*a2 ) / a2_13 ) * ( -2.5 * Roughness * ( 1 - NoV ) + 1 );
    float Lm = ( max( 1 - 2*a, 0 ) * ( 1 - pow5( 1 - pbrInputs.NdotL ) ) + min( 2*a, 1 ) ) * ( 1 - 0.5*a * (pbrInputs.NdotL - 1) ) * pbrInputs.NdotL;
    float Vd = ( a2 / ( (a2 + 0.09) * (1.31072 + 0.995584 * pbrInputs.NdotV) ) ) * ( 1 - pow( 1 - pbrInputs.NdotL, ( 1 - 0.3726732 * pbrInputs.NdotV * pbrInputs.NdotV ) / ( 0.188566 + 0.38841 * pbrInputs.NdotV ) ) );
    float Bp = Cosri < 0 ? 1.4 * pbrInputs.NdotV * pbrInputs.NdotL * Cosri : Cosri;
    float Lr = (21.0 / 20.0) * (1 - F0) * ( Fr * Lm + Vd + Bp );
    return pbrInputs.diffuseColor * RECIPROCAL_PI * Lr;
}

vec3 BRDF_Diffuse_Burley(PBRInfo pbrInputs)
{
    float energyBias = mix(pbrInputs.perceptualRoughness, 0.0, 0.5);
    float energyFactor = mix(pbrInputs.perceptualRoughness, 1.0, 1.0 / 1.51);
    float fd90 = energyBias + 2.0 * pbrInputs.VdotH * pbrInputs.VdotH * pbrInputs.perceptualRoughness;
    float f0 = 1.0;
    float lightScatter = f0 + (fd90 - f0) * pow(1.0 - pbrInputs.NdotL, 5.0);
    float viewScatter = f0 + (fd90 - f0) * pow(1.0 - pbrInputs.NdotV, 5.0);

    return pbrInputs.diffuseColor * lightScatter * viewScatter * energyFactor;
}

vec3 BRDF_Diffuse_Disney(PBRInfo pbrInputs)
{
	float Fd90 = 0.5 + 2.0 * pbrInputs.perceptualRoughness * pbrInputs.VdotH * pbrInputs.VdotH;
    vec3 f0 = vec3(0.1);
	vec3 invF0 = vec3(1.0, 1.0, 1.0) - f0;
	float dim = min(invF0.r, min(invF0.g, invF0.b));
	float result = ((1.0 + (Fd90 - 1.0) * pow(1.0 - pbrInputs.NdotL, 5.0 )) * (1.0 + (Fd90 - 1.0) * pow(1.0 - pbrInputs.NdotV, 5.0 ))) * dim;
	return pbrInputs.diffuseColor * result;
}

// The following equation models the Fresnel reflectance term of the spec equation (aka F())
// Implementation of fresnel from [4], Equation 15
vec3 specularReflection(PBRInfo pbrInputs)
{
    //return pbrInputs.reflectance0 + (pbrInputs.reflectance90 - pbrInputs.reflectance0) * pow(clamp(1.0 - pbrInputs.VdotH, 0.0, 1.0), 5.0);
    return pbrInputs.reflectance0 + (pbrInputs.reflectance90 - pbrInputs.reflectance90*pbrInputs.reflectance0) * exp2((-5.55473 * pbrInputs.VdotH - 6.98316) * pbrInputs.VdotH);
}

// This calculates the specular geometric attenuation (aka G()),
// where rougher material will reflect less light back to the viewer.
// This implementation is based on [1] Equation 4, and we adopt their modifications to
// alphaRoughness as input as originally proposed in [2].
float geometricOcclusion(PBRInfo pbrInputs)
{
    float NdotL = pbrInputs.NdotL;
    float NdotV = pbrInputs.NdotV;
    float r = pbrInputs.alphaRoughness * pbrInputs.alphaRoughness;

    float attenuationL = 2.0 * NdotL / (NdotL + sqrt(r + (1.0 - r) * (NdotL * NdotL)));
    float attenuationV = 2.0 * NdotV / (NdotV + sqrt(r + (1.0 - r) * (NdotV * NdotV)));
    return attenuationL * attenuationV;
}

// The following equation(s) model the distribution of microfacet normals across the area being drawn (aka D())
// Implementation from \"Average Irregularity Representation of a Roughened Surface for Ray Reflection\" by T. S. Trowbridge, and K. P. Reitz
// Follows the distribution function recommended in the SIGGRAPH 2013 course notes from EPIC Games [1], Equation 3.
float microfacetDistribution(PBRInfo pbrInputs)
{
    float roughnessSq = pbrInputs.alphaRoughness * pbrInputs.alphaRoughness;
    float f = (pbrInputs.NdotH * roughnessSq - pbrInputs.NdotH) * pbrInputs.NdotH + 1.0;
    return roughnessSq / (PI * f * f);
}

vec3 BRDF(vec3 v, vec3 n, vec3 l, vec3 h, float perceptualRoughness, float metallic, vec3 specularEnvironmentR0, vec3 specularEnvironmentR90, float alphaRoughness, vec3 diffuseColor, vec3 specularColor, float ao)
{
    vec3 reflection = -normalize(reflect(v, n));
    reflection.y *= -1.0f;

    float NdotL = clamp(dot(n, l), 0.001, 1.0);
    float NdotV = clamp(abs(dot(n, v)), 0.001, 1.0);
    float NdotH = clamp(dot(n, h), 0.0, 1.0);
    float LdotH = clamp(dot(l, h), 0.0, 1.0);
    float VdotH = clamp(dot(v, h), 0.0, 1.0);
    float VdotL = clamp(dot(v, l), 0.0, 1.0);

    PBRInfo pbrInputs = PBRInfo(NdotL,
                                NdotV,
                                NdotH,
                                LdotH,
                                VdotH,
                                VdotL,
                                perceptualRoughness,
                                metallic,
                                specularEnvironmentR0,
                                specularEnvironmentR90,
                                alphaRoughness,
                                diffuseColor,
                                specularColor);

    // Calculate the shading terms for the microfacet specular shading model
    vec3 F = specularReflection(pbrInputs);
    float G = geometricOcclusion(pbrInputs);
    float D = microfacetDistribution(pbrInputs);

    const vec3 u_LightColor = vec3(1.0);

    // Calculation of analytical lighting contribution
    vec3 diffuseContrib = (1.0 - F) * BRDF_Diffuse_Disney(pbrInputs);
    vec3 specContrib = F * G * D / (4.0 * NdotL * NdotV);
    // Obtain final intensity as reflectance (BRDF) scaled by the energy of the light (cosine law)
    vec3 color = NdotL * u_LightColor * (diffuseContrib + specContrib);

    color *= ao;

#ifdef VSG_EMISSIVE_MAP
    vec3 emissive = SRGBtoLINEAR(texture(emissiveMap, texCoord0)).rgb * pbr.emissiveFactor.rgb;
#else
    vec3 emissive = pbr.emissiveFactor.rgb;
#endif
    color += emissive;

    return color;
}

float convertMetallic(vec3 diffuse, vec3 specular, float maxSpecular)
{
    float perceivedDiffuse = sqrt(0.299 * diffuse.r * diffuse.r + 0.587 * diffuse.g * diffuse.g + 0.114 * diffuse.b * diffuse.b);
    float perceivedSpecular = sqrt(0.299 * specular.r * specular.r + 0.587 * specular.g * specular.g + 0.114 * specular.b * specular.b);

    if (perceivedSpecular < c_MinRoughness)
    {
        return 0.0;
    }

    float a = c_MinRoughness;
    float b = perceivedDiffuse * (1.0 - maxSpecular) / (1.0 - c_MinRoughness) + perceivedSpecular - 2.0 * c_MinRoughness;
    float c = c_MinRoughness - perceivedSpecular;
    float D = max(b * b - 4.0 * a * c, 0.0);
    return clamp((-b + sqrt(D)) / (2.0 * a), 0.0, 1.0);
}

void main()
{
    float perceptualRoughness = 0.0;
    float metallic;
    vec3 diffuseColor;
    vec4 baseColor;

    float ambientOcclusion = 1.0;

    vec3 f0 = vec3(0.04);

#ifdef VSG_DIFFUSE_MAP
    baseColor = SRGBtoLINEAR(texture(diffuseMap, texCoord0)) * pbr.baseColorFactor;
#else
    baseColor = pbr.baseColorFactor;
#endif

    if (pbr.alphaMask == 1.0f)
    {
        if (baseColor.a < pbr.alphaMaskCutoff)
            discard;
    }


#ifdef VSG_WORKFLOW_SPECGLOSS
    #ifdef VSG_SPECULAR_MAP
        vec3 specular = SRGBtoLINEAR(texture(specularMap, texCoord0)).rgb;
        perceptualRoughness = 1.0 - texture(specularMap, texCoord0).a;
    #else
        vec3 specular = vec3(0.0);
        perceptualRoughness = 0.0;
    #endif

        const float epsilon = 1e-6;

    #ifdef VSG_DIFFUSE_MAP
        vec4 diffuse = SRGBtoLINEAR(texture(diffuseMap, texCoord0));
    #else
        vec4 diffuse = vec4(1.0);
    #endif

        float maxSpecular = max(max(specular.r, specular.g), specular.b);

        // Convert metallic value from specular glossiness inputs
        metallic = convertMetallic(diffuse.rgb, specular, maxSpecular);

        vec3 baseColorDiffusePart = diffuse.rgb * ((1.0 - maxSpecular) / (1 - c_MinRoughness) / max(1 - metallic, epsilon)) * pbr.diffuseFactor.rgb;
        vec3 baseColorSpecularPart = specular - (vec3(c_MinRoughness) * (1 - metallic) * (1 / max(metallic, epsilon))) * pbr.specularFactor.rgb;
        baseColor = vec4(mix(baseColorDiffusePart, baseColorSpecularPart, metallic * metallic), diffuse.a);
#else
        perceptualRoughness = pbr.roughnessFactor;
        metallic = pbr.metallicFactor;

    #ifdef VSG_METALLROUGHNESS_MAP
        vec4 mrSample = texture(mrMap, texCoord0);
        perceptualRoughness = mrSample.g * perceptualRoughness;
        metallic = mrSample.b * metallic;
    #endif
#endif

#ifdef VSG_LIGHTMAP_MAP
    ambientOcclusion = texture(aoMap, texCoord0).r;
#endif

    diffuseColor = baseColor.rgb * (vec3(1.0) - f0);
    diffuseColor *= 1.0 - metallic;

    float alphaRoughness = perceptualRoughness * perceptualRoughness;

    vec3 specularColor = mix(f0, baseColor.rgb, metallic);

    // Compute reflectance.
    float reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);

    // For typical incident reflectance range (between 4% to 100%) set the grazing reflectance to 100% for typical fresnel effect.
    // For very low reflectance range on highly diffuse objects (below 4%), incrementally reduce grazing reflecance to 0%.
    float reflectance90 = clamp(reflectance * 25.0, 0.0, 1.0);
    vec3 specularEnvironmentR0 = specularColor.rgb;
    vec3 specularEnvironmentR90 = vec3(1.0, 1.0, 1.0) * reflectance90;

    vec3 n = getNormal();
    vec3 v = normalize(viewDir);    // Vector from surface point to camera
    vec3 l = normalize(lightDir);     // Vector from surface point to light
    vec3 h = normalize(l+v);                        // Half vector between both l and v

    vec3 colorFrontFace = BRDF(v, n, l, h, perceptualRoughness, metallic, specularEnvironmentR0, specularEnvironmentR90, alphaRoughness, diffuseColor, specularColor, ambientOcclusion);
#ifdef VSG_TWOSIDED
    vec3 colorBackFace = BRDF(v, -n, l, h, perceptualRoughness, metallic, specularEnvironmentR0, specularEnvironmentR90, alphaRoughness, diffuseColor, specularColor, ambientOcclusion);
    vec3 color = colorFrontFace+colorBackFace;
#else
    vec3 color = colorFrontFace;
#endif

    outColor = LINEARtoSRGB(vec4(color, baseColor.a));
}
"
                  SPIRVSize 0
                  SPIRV
                }
                NumSpecializationConstants 0
              }
              NumPipelineStates 6
              PipelineState id=71 vsg::VertexInputState
              {
                NumUserObjects 0
                NumBindings 3
                binding 0
                stride 12
                inputRate 0
                binding 1
                stride 12
                inputRate 0
                binding 2
                stride 8
                inputRate 0
                NumAttributes 3
                location 0
                binding 0
                format 106
                offset 0
                location 1
                binding 1
                format 106
                offset 0
                location 2
                binding 2
                format 103
                offset 0
              }
              PipelineState id=72 vsg::InputAssemblyState
              {
                NumUserObjects 0
                topology 3
                primitiveRestartEnable 0
              }
              PipelineState id=73 vsg::RasterizationState
              {
                NumUserObjects 0
                depthClampEnable 0
                rasterizerDiscardEnable 0
                polygonMode 0
                cullMode 0
                frontFace 0
                depthBiasEnable 0
                depthBiasConstantFactor 1
                depthBiasClamp 0
                depthBiasSlopeFactor 1
                lineWidth 1
              }
              PipelineState id=74 vsg::MultisampleState
              {
                NumUserObjects 0
                rasterizationSamples 1
                sampleShadingEnable 0
                minSampleShading 0
                NumSampleMask 0
                alphaToCoverageEnable 0
                alphaToOneEnable 0
              }
              PipelineState id=75 vsg::ColorBlendState
              {
                NumUserObjects 0
                logicOp 3
                logicOpEnable 0
                NumColorBlendAttachments 1
                blendEnable 0
                srcColorBlendFactor 6
                dstColorBlendFactor 7
                colorBlendOp 0
                srcAlphaBlendFactor 6
                dstAlphaBlendFactor 7
                alphaBlendOp 1
                colorWriteMask 15
                blendConstants 0 0 0 0
              }
              PipelineState id=76 vsg::DepthStencilState
              {
                NumUserObjects 0
                depthTestEnable 1
                depthWriteEnable 1
                depthCompareOp 1
                depthBoundsTestEnable 0
                stencilTestEnable 0
                front.failOp 0
                front.passOp 0
                front.depthFailOp 0
                front.compareOp 0
                front.compareMask 0
                front.writeMask 0
                front.reference 0
                back.failOp 0
                back.passOp 0
                back.depthFailOp 0
                back.compareOp 0
                back.compareMask 0
                back.writeMask 0
                back.reference 0
                minDepthBounds 0
                maxDepthBounds 1
              }
              subpass 0
            }
          }
          StateCommand id=77 vsg::BindDescriptorSet
          {
            NumUserObjects 0
            Slot 1
            PipelineLayout id=65
            firstSet 0
            DescriptorSet id=78 vsg::DescriptorSet
            {
              NumUserObjects 0
              DescriptorSetLayout id=66
              NumDescriptors 1
              Descriptor id=79 vsg::DescriptorBuffer
              {
                NumUserObjects 0
                DstBinding 10
                DstArrayElement 0
                NumData 1
                Data id=80 vsg::ubyteArray
                {
                  NumUserObjects 0
                  Layout 0 1 0 1 1 1 0 -1
                  Size 80
                  Storage id=0
                  Data 0 0 0 0 0 0 0 0 0 0 0 0
                   0 0 128 63 0 0 0 0 0 0 0 0
                   0 0 0 0 0 0 128 63 0 0 128 63
                   0 0 128 63 0 0 128 63 0 0 128 63
                   0 0 0 0 0 0 0 0 0 0 0 0
                   0 0 128 63 0 0 0 0 205 204 204 62
                   0 0 128 63 0 0 0 63
                }
              }
            }
          }
        }
        Matrix 0.1 0 0 0 0 0.1 0 0 0 0 1 0
         2 -1 1 1
        SubgraphRequiresLocalFrustum 1
      }
      Child id=81 vsg::MatrixTransform
      {
        NumUserObjects 0
        NumChildren 1
        Child id=82 vsg::StateGroup
        {
          NumUserObjects 0
          NumChildren 1
          Child id=83 vsg::VertexIndexDraw
          {
            NumUserObjects 0
            firstBinding 0
            NumArrays 3
            Array id=84 vsg::vec3Array
            {
              NumUserObjects 0
              Layout 0 12 0 1 1 1 0 -1
              Size 24
              Storage id=0
              Data 1 1 1 1 1 1 1 1 1 1 1 -1
               1 1 -1 1 1 -1 1 -1 1 1 -1 1
               1 -1 1 1 -1 -1 1 -1 -1 1 -1 -1
               -1 1 1 -1 1 1 -1 1 1 -1 1 -1
               -1 1 -1 -1 1 -1 -1 -1 1 -1 -1 1
               -1 -1 1 -1 -1 -1 -1 -1 -1 -1 -1 -1
            }
            Array id=85 vsg::vec3Array
            {
              NumUserObjects 0
              Layout 0 12 0 1 1 1 0 -1
              Size 24
              Storage id=0
              Data 0 0 1 0 1 0 1 0 0 0 0 -1
               0 1 0 1 0 0 0 -1 0 0 0 1
               1 0 0 0 -1 0 0 0 -1 1 0 0
               -1 0 0 0 0 1 0 1 0 -1 0 0
               0 0 -1 0 1 0 -1 0 0 0 -1 0
               0 0 1 -1 0 0 0 -1 0 0 0 -1
            }
            Array id=86 vsg::vec2Array
            {
              NumUserObjects 0
              Layout 0 8 0 1 1 1 0 -1
              Size 24
              Storage id=0
              Data 0.625 0.5 0.625 0.5 0.625 0.5 0.375 0.5 0.375 0.5 0.375 0.5
               0.625 0.25 0.625 0.25 0.625 0.25 0.375 0.25 0.375 0.25 0.375 0.25
               0.625 0.75 0.875 0.5 0.625 0.75 0.375 0.75 0.125 0.5 0.375 0.75
               0.625 1 0.625 0 0.875 0.25 0.375 1 0.375 0 0.125 0.25
            }
            Indices id=87 vsg::ushortArray
            {
              NumUserObjects 0
              Layout 0 2 0 1 1 1 0 -1
              Size 36
              Storage id=0
              Data 0 13 20 0 20 7 5 2 8 5 8 11
               16 3 10 16 10 23 17 1 4 17 14 1
               9 6 19 9 19 22 21 18 12 21 12 15
            }
            indexCount 36
            instanceCount 1
            firstIndex 0
            vertexOffset 0
            firstInstance 0
          }
          NumStateCommands 2
          StateCommand id=88 vsg::BindGraphicsPipeline
          {
            NumUserObjects 0
            Slot 0
            GraphicsPipeline id=89 vsg::GraphicsPipeline
            {
              NumUserObjects 0
              PipelineLayout id=90 vsg::PipelineLayout
              {
                NumUserObjects 0
                Flags 0
                NumDescriptorSetLayouts 1
                DescriptorSetLayout id=91 vsg::DescriptorSetLayout
                {
                  NumUserObjects 0
                  NumDescriptorSetLayoutBindings 1
                  binding 10
                  descriptorType 6
                  descriptorCount 1
                  stageFlags 16
                }
                NumPushConstantRanges 1
                stageFlags 1
                offset 0
                size 128
              }
              NumShaderStages 2
              ShaderStage id=92 vsg::ShaderStage
              {
                NumUserObjects 0
                Stage 1
                EntryPoint "main"
                ShaderModule id=93 vsg::ShaderModule
                {
                  NumUserObjects 0
                  Source "#version 450

#extension GL_ARB_separate_shader_objects : enable

layout(push_constant) uniform PushConstants {
    mat4 projection;
    mat4 modelView;
} pc;

layout(location = 0) in vec3 osg_Vertex;
layout(location = 0) out vec3 worldPos;

layout(location = 1) in vec3 osg_Normal;
layout(location = 1) out vec3 normalDir;

layout(location = 2) in vec2 osg_TexCoord0;
layout(location = 2) out vec2 texCoord0;

layout(location = 5) out vec3 viewDir;
layout(location = 6) out vec3 lightDir;

out gl_PerVertex{ vec4 gl_Position; };

void main()
{
    gl_Position = (pc.projection * pc.modelView) * vec4(osg_Vertex, 1.0);
    worldPos = vec4(pc.modelView * vec4(osg_Vertex, 1.0)).xyz;

    vec3 n = (pc.modelView * vec4(osg_Normal, 0.0)).xyz;
    normalDir = n;
    vec4 lpos = /*osg_LightSource.position*/ vec4(0.0, 0.25, 1.0, 0.0);
    viewDir = -vec3(pc.modelView * vec4(osg_Vertex, 1.0));

    if (lpos.w == 0.0)
        lightDir = lpos.xyz;
    else
        lightDir = lpos.xyz + viewDir;

    texCoord0 = osg_TexCoord0 * vec2(1,1);
}
"
                  SPIRVSize 0
                  SPIRV
                }
                NumSpecializationConstants 0
              }
              ShaderStage id=94 vsg::ShaderStage
              {
                NumUserObjects 0
                Stage 16
                EntryPoint "main"
                ShaderModule id=95 vsg::ShaderModule
                {
                  NumUserObjects 0
                  Source "#version 450
#pragma import_defines (VSG_DIFFUSE_MAP, VSG_EMISSIVE_MAP, VSG_LIGHTMAP_MAP, VSG_NORMAL_MAP, VSG_METALLROUGHNESS_MAP, VSG_SPECULAR_MAP, VSG_TWOSIDED, VSG_WORKFLOW_SPECGLOSS)
#define VSG_TWOSIDED

#extension GL_ARB_separate_shader_objects : enable

const float PI = 3.14159265359;
const float RECIPROCAL_PI = 0.31830988618;
const float RECIPROCAL_PI2 = 0.15915494;
const float EPSILON = 1e-6;
const float c_MinRoughness = 0.04;

#ifdef VSG_DIFFUSE_MAP
layout(binding = 0) uniform sampler2D diffuseMap;
#endif

#ifdef VSG_METALLROUGHNESS_MAP
layout(binding = 1) uniform sampler2D mrMap;
#endif

#ifdef VSG_NORMAL_MAP
layout(binding = 2) uniform sampler2D normalMap;
#endif

#ifdef VSG_LIGHTMAP_MAP
layout(binding = 3) uniform sampler2D aoMap;
#endif

#ifdef VSG_EMISSIVE_MAP
layout(binding = 4) uniform sampler2D emissiveMap;
#endif

#ifdef VSG_SPECULAR_MAP
layout(binding = 5) uniform sampler2D specularMap;
#endif

layout(push_constant) uniform PushConstants {
    mat4 projection;
    mat4 modelView;
} pc;

layout(binding = 10) uniform PbrData
{
    vec4 baseColorFactor;
    vec4 emissiveFactor;
    vec4 diffuseFactor;
    vec4 specularFactor;
    float metallicFactor;
    float roughnessFactor;
    float alphaMask;
    float alphaMaskCutoff;
} pbr;

layout(location = 0) in vec3 worldPos;
layout(location = 1) in vec3 normalDir;
layout(location = 2) in vec2 texCoord0;
layout(location = 5) in vec3 viewDir;
layout(location = 6) in vec3 lightDir;

layout(location = 0) out vec4 outColor;


// Encapsulate the various inputs used by the various functions in the shading equation
// We store values in this struct to simplify the integration of alternative implementations
// of the shading terms, outlined in the Readme.MD Appendix.
struct PBRInfo
{
    float NdotL;                  // cos angle between normal and light direction
    float NdotV;                  // cos angle between normal and view direction
    float NdotH;                  // cos angle between normal and half vector
    float LdotH;                  // cos angle between light direction and half vector
    float VdotH;                  // cos angle between view direction and half vector
    float VdotL;                  // cos angle between view direction and light direction
    float perceptualRoughness;    // roughness value, as authored by the model creator (input to shader)
    float metalness;              // metallic value at the surface
    vec3 reflectance0;            // full reflectance color (normal incidence angle)
    vec3 reflectance90;           // reflectance color at grazing angle
    float alphaRoughness;         // roughness mapped to a more linear change in the roughness (proposed by [2])
    vec3 diffuseColor;            // color contribution from diffuse lighting
    vec3 specularColor;           // color contribution from specular lighting
};


vec4 SRGBtoLINEAR(vec4 srgbIn)
{
    vec3 linOut = pow(srgbIn.xyz, vec3(2.2));
    return vec4(linOut,srgbIn.w);
}

vec4 LINEARtoSRGB(vec4 srgbIn)
{
    vec3 linOut = pow(srgbIn.xyz, vec3(1.0 / 2.2));
    return vec4(linOut, srgbIn.w);
}

float rcp(const in float value)
{
    return 1.0 / value;
}

float pow5(const in float value)
{
    return value * value * value * value * value;
}

// Find the normal for this fragment, pulling either from a predefined normal map
// or from the interpolated mesh normal and tangent attributes.
vec3 getNormal()
{
#ifdef VSG_NORMAL_MAP
    // Perturb normal, see http://www.thetenthplanet.de/archives/1180
    vec3 tangentNormal = texture(normalMap, texCoord0).xyz * 2.0 - 1.0;

    //tangentNormal *= vec3(2,2,1);

    vec3 q1 = dFdx(worldPos);
    vec3 q2 = dFdy(worldPos);
    vec2 st1 = dFdx(texCoord0);
    vec2 st2 = dFdy(texCoord0);

    vec3 N = normalize(normalDir);
    vec3 T = normalize(q1 * st2.t - q2 * st1.t);
    vec3 B = -normalize(cross(N, T));
    mat3 TBN = mat3(T, B, N);

    return normalize(TBN * tangentNormal);
#else
    return normalize(normalDir);
#endif
}

// Basic Lambertian diffuse
// Implementation from Lambert's Photometria https://archive.org/details/lambertsphotome00lambgoog
// See also [1], Equation 1
vec3 BRDF_Diffuse_Lambert(PBRInfo pbrInputs)
{
    return pbrInputs.diffuseColor * RECIPROCAL_PI;
}

vec3 BRDF_Diffuse_Custom_Lambert(PBRInfo pbrInputs)
{
    return pbrInputs.diffuseColor * RECIPROCAL_PI * pow(pbrInputs.NdotV, 0.5 + 0.3 * pbrInputs.perceptualRoughness);
}

// [Gotanda 2012, \"Beyond a Simple Physically Based Blinn-Phong Model in Real-Time\"]
vec3 BRDF_Diffuse_OrenNayar(PBRInfo pbrInputs)
{
    float a = pbrInputs.alphaRoughness;
    float s = a;// / ( 1.29 + 0.5 * a );
    float s2 = s * s;
    float VoL = 2 * pbrInputs.VdotH * pbrInputs.VdotH - 1;		// double angle identity
    float Cosri = pbrInputs.VdotL - pbrInputs.NdotV * pbrInputs.NdotL;
    float C1 = 1 - 0.5 * s2 / (s2 + 0.33);
    float C2 = 0.45 * s2 / (s2 + 0.09) * Cosri * ( Cosri >= 0 ? 1.0 / max(pbrInputs.NdotL, pbrInputs.NdotV) : 1 );
    return pbrInputs.diffuseColor / PI * ( C1 + C2 ) * ( 1 + pbrInputs.perceptualRoughness * 0.5 );
}

// [Gotanda 2014, \"Designing Reflectance Models for New Consoles\"]
vec3 BRDF_Diffuse_Gotanda(PBRInfo pbrInputs)
{
    float a = pbrInputs.alphaRoughness;
    float a2 = a * a;
    float F0 = 0.04;
    float VoL = 2 * pbrInputs.VdotH * pbrInputs.VdotH - 1;		// double angle identity
    float Cosri = VoL - pbrInputs.NdotV * pbrInputs.NdotL;
    float a2_13 = a2 + 1.36053;
    float Fr = ( 1 - ( 0.542026*a2 + 0.303573*a ) / a2_13 ) * ( 1 - pow( 1 - pbrInputs.NdotV, 5 - 4*a2 ) / a2_13 ) * ( ( -0.733996*a2*a + 1.50912*a2 - 1.16402*a ) * pow( 1 - pbrInputs.NdotV, 1 + rcp(39*a2*a2+1) ) + 1 );
    //float Fr = ( 1 - 0.36 * a ) * ( 1 - pow( 1 - NoV, 5 - 4*a2 ) / a2_13 ) * ( -2.5 * Roughness * ( 1 - NoV ) + 1 );
    float Lm = ( max( 1 - 2*a, 0 ) * ( 1 - pow5( 1 - pbrInputs.NdotL ) ) + min( 2*a, 1 ) ) * ( 1 - 0.5*a * (pbrInputs.NdotL - 1) ) * pbrInputs.NdotL;
    float Vd = ( a2 / ( (a2 + 0.09) * (1.31072 + 0.995584 * pbrInputs.NdotV) ) ) * ( 1 - pow( 1 - pbrInputs.NdotL, ( 1 - 0.3726732 * pbrInputs.NdotV * pbrInputs.NdotV ) / ( 0.188566 + 0.38841 * pbrInputs.NdotV ) ) );
    float Bp = Cosri < 0 ? 1.4 * pbrInputs.NdotV * pbrInputs.NdotL * Cosri : Cosri;
    float Lr = (21.0 / 20.0) * (1 - F0) * ( Fr * Lm + Vd + Bp );
    return pbrInputs.diffuseColor * RECIPROCAL_PI * Lr;
}

vec3 BRDF_Diffuse_Burley(PBRInfo pbrInputs)
{
    float energyBias = mix(pbrInputs.perceptualRoughness, 0.0, 0.5);
    float energyFactor = mix(pbrInputs.perceptualRoughness, 1.0, 1.0 / 1.51);
    float fd90 = energyBias + 2.0 * pbrInputs.VdotH * pbrInputs.VdotH * pbrInputs.perceptualRoughness;
    float f0 = 1.0;
    float lightScatter = f0 + (fd90 - f0) * pow(1.0 - pbrInputs.NdotL, 5.0);
    float viewScatter = f0 + (fd90 - f0) * pow(1.0 - pbrInputs.NdotV, 5.0);

    return pbrInputs.diffuseColor * lightScatter * viewScatter * energyFactor;
}

vec3 BRDF_Diffuse_Disney(PBRInfo pbrInputs)
{
	float Fd90 = 0.5 + 2.0 * pbrInputs.perceptualRoughness * pbrInputs.VdotH * pbrInputs.VdotH;
    vec3 f0 = vec3(0.1);
	vec3 invF0 = vec3(1.0, 1.0, 1.0) - f0;
	float dim = min(invF0.r, min(invF0.g, invF0.b));
	float result = ((1.0 + (Fd90 - 1.0) * pow(1.0 - pbrInputs.NdotL, 5.0 )) * (1.0 + (Fd90 - 1.0) * pow(1.0 - pbrInputs.NdotV, 5.0 ))) * dim;
	return pbrInputs.diffuseColor * result;
}

// The following equation models the Fresnel reflectance term of the spec equation (aka F())
// Implementation of fresnel from [4], Equation 15
vec3 specularReflection(PBRInfo pbrInputs)
{
    //return pbrInputs.reflectance0 + (pbrInputs.reflectance90 - pbrInputs.reflectance0) * pow(clamp(1.0 - pbrInputs.VdotH, 0.0, 1.0), 5.0);
    return pbrInputs.reflectance0 + (pbrInputs.reflectance90 - pbrInputs.reflectance90*pbrInputs.reflectance0) * exp2((-5.55473 * pbrInputs.VdotH - 6.98316) * pbrInputs.VdotH);
}

// This calculates the specular geometric attenuation (aka G()),
// where rougher material will reflect less light back to the viewer.
// This implementation is based on [1] Equation 4, and we adopt their modifications to
// alphaRoughness as input as originally proposed in [2].
float geometricOcclusion(PBRInfo pbrInputs)
{
    float NdotL = pbrInputs.NdotL;
    float NdotV = pbrInputs.NdotV;
    float r = pbrInputs.alphaRoughness * pbrInputs.alphaRoughness;

    float attenuationL = 2.0 * NdotL / (NdotL + sqrt(r + (1.0 - r) * (NdotL * NdotL)));
    float attenuationV = 2.0 * NdotV / (NdotV + sqrt(r + (1.0 - r) * (NdotV * NdotV)));
    return attenuationL * attenuationV;
}

// The following equation(s) model the distribution of microfacet normals across the area being drawn (aka D())
// Implementation from \"Average Irregularity Representation of a Roughened Surface for Ray Reflection\" by T. S. Trowbridge, and K. P. Reitz
// Follows the distribution function recommended in the SIGGRAPH 2013 course notes from EPIC Games [1], Equation 3.
float microfacetDistribution(PBRInfo pbrInputs)
{
    float roughnessSq = pbrInputs.alphaRoughness * pbrInputs.alphaRoughness;
    float f = (pbrInputs.NdotH * roughnessSq - pbrInputs.NdotH) * pbrInputs.NdotH + 1.0;
    return roughnessSq / (PI * f * f);
}

vec3 BRDF(vec3 v, vec3 n, vec3 l, vec3 h, float perceptualRoughness, float metallic, vec3 specularEnvironmentR0, vec3 specularEnvironmentR90, float alphaRoughness, vec3 diffuseColor, vec3 specularColor, float ao)
{
    vec3 reflection = -normalize(reflect(v, n));
    reflection.y *= -1.0f;

    float NdotL = clamp(dot(n, l), 0.001, 1.0);
    float NdotV = clamp(abs(dot(n, v)), 0.001, 1.0);
    float NdotH = clamp(dot(n, h), 0.0, 1.0);
    float LdotH = clamp(dot(l, h), 0.0, 1.0);
    float VdotH = clamp(dot(v, h), 0.0, 1.0);
    float VdotL = clamp(dot(v, l), 0.0, 1.0);

    PBRInfo pbrInputs = PBRInfo(NdotL,
                                NdotV,
                                NdotH,
                                LdotH,
                                VdotH,
                                VdotL,
                                perceptualRoughness,
                                metallic,
                                specularEnvironmentR0,
                                specularEnvironmentR90,
                                alphaRoughness,
                                diffuseColor,
                                specularColor);

    // Calculate the shading terms for the microfacet specular shading model
    vec3 F = specularReflection(pbrInputs);
    float G = geometricOcclusion(pbrInputs);
    float D = microfacetDistribution(pbrInputs);

    const vec3 u_LightColor = vec3(1.0);

    // Calculation of analytical lighting contribution
    vec3 diffuseContrib = (1.0 - F) * BRDF_Diffuse_Disney(pbrInputs);
    vec3 specContrib = F * G * D / (4.0 * NdotL * NdotV);
    // Obtain final intensity as reflectance (BRDF) scaled by the energy of the light (cosine law)
    vec3 color = NdotL * u_LightColor * (diffuseContrib + specContrib);

    color *= ao;

#ifdef VSG_EMISSIVE_MAP
    vec3 emissive = SRGBtoLINEAR(texture(emissiveMap, texCoord0)).rgb * pbr.emissiveFactor.rgb;
#else
    vec3 emissive = pbr.emissiveFactor.rgb;
#endif
    color += emissive;

    return color;
}

float convertMetallic(vec3 diffuse, vec3 specular, float maxSpecular)
{
    float perceivedDiffuse = sqrt(0.299 * diffuse.r * diffuse.r + 0.587 * diffuse.g * diffuse.g + 0.114 * diffuse.b * diffuse.b);
    float perceivedSpecular = sqrt(0.299 * specular.r * specular.r + 0.587 * specular.g * specular.g + 0.114 * specular.b * specular.b);

    if (perceivedSpecular < c_MinRoughness)
    {
        return 0.0;
    }

    float a = c_MinRoughness;
    float b = perceivedDiffuse * (1.0 - maxSpecular) / (1.0 - c_MinRoughness) + perceivedSpecular - 2.0 * c_MinRoughness;
    float c = c_MinRoughness - perceivedSpecular;
    float D = max(b * b - 4.0 * a * c, 0.0);
    return clamp((-b + sqrt(D)) / (2.0 * a), 0.0, 1.0);
}

void main()
{
    float perceptualRoughness = 0.0;
    float metallic;
    vec3 diffuseColor;
    vec4 baseColor;

    float ambientOcclusion = 1.0;

    vec3 f0 = vec3(0.04);

#ifdef VSG_DIFFUSE_MAP
    baseColor = SRGBtoLINEAR(texture(diffuseMap, texCoord0)) * pbr.baseColorFactor;
#else
    baseColor = pbr.baseColorFactor;
#endif

    if (pbr.alphaMask == 1.0f)
    {
        if (baseColor.a < pbr.alphaMaskCutoff)
            discard;
    }


#ifdef VSG_WORKFLOW_SPECGLOSS
    #ifdef VSG_SPECULAR_MAP
        vec3 specular = SRGBtoLINEAR(texture(specularMap, texCoord0)).rgb;
        perceptualRoughness = 1.0 - texture(specularMap, texCoord0).a;
    #else
        vec3 specular = vec3(0.0);
        perceptualRoughness = 0.0;
    #endif

        const float epsilon = 1e-6;

    #ifdef VSG_DIFFUSE_MAP
        vec4 diffuse = SRGBtoLINEAR(texture(diffuseMap, texCoord0));
    #else
        vec4 diffuse = vec4(1.0);
    #endif

        float maxSpecular = max(max(specular.r, specular.g), specular.b);

        // Convert metallic value from specular glossiness inputs
        metallic = convertMetallic(diffuse.rgb, specular, maxSpecular);

        vec3 baseColorDiffusePart = diffuse.rgb * ((1.0 - maxSpecular) / (1 - c_MinRoughness) / max(1 - metallic, epsilon)) * pbr.diffuseFactor.rgb;
        vec3 baseColorSpecularPart = specular - (vec3(c_MinRoughness) * (1 - metallic) * (1 / max(metallic, epsilon))) * pbr.specularFactor.rgb;
        baseColor = vec4(mix(baseColorDiffusePart, baseColorSpecularPart, metallic * metallic), diffuse.a);
#else
        perceptualRoughness = pbr.roughnessFactor;
        metallic = pbr.metallicFactor;

    #ifdef VSG_METALLROUGHNESS_MAP
        vec4 mrSample = texture(mrMap, texCoord0);
        perceptualRoughness = mrSample.g * perceptualRoughness;
        metallic = mrSample.b * metallic;
    #endif
#endif

#ifdef VSG_LIGHTMAP_MAP
    ambientOcclusion = texture(aoMap, texCoord0).r;
#endif

    diffuseColor = baseColor.rgb * (vec3(1.0) - f0);
    diffuseColor *= 1.0 - metallic;

    float alphaRoughness = perceptualRoughness * perceptualRoughness;

    vec3 specularColor = mix(f0, baseColor.rgb, metallic);

    // Compute reflectance.
    float reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);

    // For typical incident reflectance range (between 4% to 100%) set the grazing reflectance to 100% for typical fresnel effect.
    // For very low reflectance range on highly diffuse objects (below 4%), incrementally reduce grazing reflecance to 0%.
    float reflectance90 = clamp(reflectance * 25.0, 0.0, 1.0);
    vec3 specularEnvironmentR0 = specularColor.rgb;
    vec3 specularEnvironmentR90 = vec3(1.0, 1.0, 1.0) * reflectance90;

    vec3 n = getNormal();
    vec3 v = normalize(viewDir);    // Vector from surface point to camera
    vec3 l = normalize(lightDir);     // Vector from surface point to light
    vec3 h = normalize(l+v);                        // Half vector between both l and v

    vec3 colorFrontFace = BRDF(v, n, l, h, perceptualRoughness, metallic, specularEnvironmentR0, specularEnvironmentR90, alphaRoughness, diffuseColor, specularColor, ambientOcclusion);
#ifdef VSG_TWOSIDED
    vec3 colorBackFace = BRDF(v, -n, l, h, perceptualRoughness, metallic, specularEnvironmentR0, specularEnvironmentR90, alphaRoughness, diffuseColor, specularColor, ambientOcclusion);
    vec3 color = colorFrontFace+colorBackFace;
#else
    vec3 color = colorFrontFace;
#endif

    outColor = LINEARtoSRGB(vec4(color, baseColor.a));
}
"
                  SPIRVSize 0
                  SPIRV
                }
                NumSpecializationConstants 0
              }
              NumPipelineStates 6
              PipelineState id=96 vsg::VertexInputState
              {
                NumUserObjects 0
                NumBindings 3
                binding 0
                stride 12
                inputRate 0
                binding 1
                stride 12
                inputRate 0
                binding 2
                stride 8
                inputRate 0
                NumAttributes 3
                location 0
                binding 0
                format 106
                offset 0
                location 1
                binding 1
                format 106
                offset 0
                location 2
                binding 2
                format 103
                offset 0
              }
              PipelineState id=97 vsg::InputAssemblyState
              {
                NumUserObjects 0
                topology 3
                primitiveRestartEnable 0
              }
              PipelineState id=98 vsg::RasterizationState
              {
                NumUserObjects 0
                depthClampEnable 0
                rasterizerDiscardEnable 0
                polygonMode 0
                cullMode 0
                frontFace 0
                depthBiasEnable 0
                depthBiasConstantFactor 1
                depthBiasClamp 0
                depthBiasSlopeFactor 1
                lineWidth 1
              }
              PipelineState id=99 vsg::MultisampleState
              {
                NumUserObjects 0
                rasterizationSamples 1
                sampleShadingEnable 0
                minSampleShading 0
                NumSampleMask 0
                alphaToCoverageEnable 0
                alphaToOneEnable 0
              }
              PipelineState id=100 vsg::ColorBlendState
              {
                NumUserObjects 0
                logicOp 3
                logicOpEnable 0
                NumColorBlendAttachments 1
                blendEnable 0
                srcColorBlendFactor 6
                dstColorBlendFactor 7
                colorBlendOp 0
                srcAlphaBlendFactor 6
                dstAlphaBlendFactor 7
                alphaBlendOp 1
                colorWriteMask 15
                blendConstants 0 0 0 0
              }
              PipelineState id=101 vsg::DepthStencilState
              {
                NumUserObjects 0
                depthTestEnable 1
                depthWriteEnable 1
                depthCompareOp 1
                depthBoundsTestEnable 0
                stencilTestEnable 0
                front.failOp 0
                front.passOp 0
                front.depthFailOp 0
                front.compareOp 0
                front.compareMask 0
                front.writeMask 0
                front.reference 0
                back.failOp 0
                back.passOp 0
                back.depthFailOp 0
                back.compareOp 0
                back.compareMask 0
                back.writeMask 0
                back.reference 0
                minDepthBounds 0
                maxDepthBounds 1
              }
              subpass 0
            }
          }
          StateCommand id=102 vsg::BindDescriptorSet
          {
            NumUserObjects 0
            Slot 1
            PipelineLayout id=90
            firstSet 0
            DescriptorSet id=103 vsg::DescriptorSet
            {
              NumUserObjects 0
              DescriptorSetLayout id=91
              NumDescriptors 1
              Descriptor id=104 vsg::DescriptorBuffer
              {
                NumUserObjects 0
                DstBinding 10
                DstArrayElement 0
                NumData 1
                Data id=105 vsg::ubyteArray
                {
                  NumUserObjects 0
                  Layout 0 1 0 1 1 1 0 -1
                  Size 80
                  Storage id=0
                  Data 0 0 0 0 0 0 0 0 0 0 0 0
                   0 0 128 63 0 0 0 0 0 0 0 0
                   0 0 0 0 0 0 128 63 0 0 128 63
                   0 0 128 63 0 0 128 63 0 0 128 63
                   0 0 0 0 0 0 0 0 0 0 0 0
                   0 0 128 63 0 0 0 0 205 204 204 62
                   0 0 128 63 0 0 0 63
                }
              }
            }
          }
        }
        Matrix 0.1 0 0 0 0 0.1 0 0 0 0 2 0
         -2 -1 2 1
        SubgraphRequiresLocalFrustum 1
      }
      Child id=106 vsg::MatrixTransform
      {
        NumUserObjects 0
        NumChildren 1
        Child id=107 vsg::StateGroup
        {
          NumUserObjects 0
          NumChildren 1
          Child id=108 vsg::VertexIndexDraw
          {
            NumUserObjects 0
            firstBinding 0
            NumArrays 3
            Array id=109 vsg::vec3Array
            {
              NumUserObjects 0
              Layout 0 12 0 1 1 1 0 -1
              Size 24
              Storage id=0
              Data 1 1 1 1 1 1 1 1 1 1 1 -1
               1 1 -1 1 1 -1 1 -1 1 1 -1 1
               1 -1 1 1 -1 -1 1 -1 -1 1 -1 -1
               -1 1 1 -1 1 1 -1 1 1 -1 1 -1
               -1 1 -1 -1 1 -1 -1 -1 1 -1 -1 1
               -1 -1 1 -1 -1 -1 -1 -1 -1 -1 -1 -1
            }
            Array id=110 vsg::vec3Array
            {
              NumUserObjects 0
              Layout 0 12 0 1 1 1 0 -1
              Size 24
              Storage id=0
              Data 0 0 1 0 1 0 1 0 0 0 0 -1
               0 1 0 1 0 0 0 -1 0 0 0 1
               1 0 0 0 -1 0 0 0 -1 1 0 0
               -1 0 0 0 0 1 0 1 0 -1 0 0
               0 0 -1 0 1 0 -1 0 0 0 -1 0
               0 0 1 -1 0 0 0 -1 0 0 0 -1
            }
            Array id=111 vsg::vec2Array
            {
              NumUserObjects 0
              Layout 0 8 0 1 1 1 0 -1
              Size 24
              Storage id=0
              Data 0.625 0.5 0.625 0.5 0.625 0.5 0.375 0.5 0.375 0.5 0.375 0.5
               0.625 0.25 0.625 0.25 0.625 0.25 0.375 0.25 0.375 0.25 0.375 0.25
               0.625 0.75 0.875 0.5 0.625 0.75 0.375 0.75 0.125 0.5 0.375 0.75
               0.625 1 0.625 0 0.875 0.25 0.375 1 0.375 0 0.125 0.25
            }
            Indices id=112 vsg::ushortArray
            {
              NumUserObjects 0
              Layout 0 2 0 1 1 1 0 -1
              Size 36
              Storage id=0
              Data 0 13 20 0 20 7 5 2 8 5 8 11
               16 3 10 16 10 23 17 1 4 17 14 1
               9 6 19 9 19 22 21 18 12 21 12 15
            }
            indexCount 36
            instanceCount 1
            firstIndex 0
            vertexOffset 0
            firstInstance 0
          }
          NumStateCommands 2
          StateCommand id=113 vsg::BindGraphicsPipeline
          {
            NumUserObjects 0
            Slot 0
            GraphicsPipeline id=114 vsg::GraphicsPipeline
            {
              NumUserObjects 0
              PipelineLayout id=115 vsg::PipelineLayout
              {
                NumUserObjects 0
                Flags 0
                NumDescriptorSetLayouts 1
                DescriptorSetLayout id=116 vsg::DescriptorSetLayout
                {
                  NumUserObjects 0
                  NumDescriptorSetLayoutBindings 1
                  binding 10
                  descriptorType 6
                  descriptorCount 1
                  stageFlags 16
                }
                NumPushConstantRanges 1
                stageFlags 1
                offset 0
                size 128
              }
              NumShaderStages 2
              ShaderStage id=117 vsg::ShaderStage
              {
                NumUserObjects 0
                Stage 1
                EntryPoint "main"
                ShaderModule id=118 vsg::ShaderModule
                {
                  NumUserObjects 0
                  Source "#version 450

#extension GL_ARB_separate_shader_objects : enable

layout(push_constant) uniform PushConstants {
    mat4 projection;
    mat4 modelView;
} pc;

layout(location = 0) in vec3 osg_Vertex;
layout(location = 0) out vec3 worldPos;

layout(location = 1) in vec3 osg_Normal;
layout(location = 1) out vec3 normalDir;

layout(location = 2) in vec2 osg_TexCoord0;
layout(location = 2) out vec2 texCoord0;

layout(location = 5) out vec3 viewDir;
layout(location = 6) out vec3 lightDir;

out gl_PerVertex{ vec4 gl_Position; };

void main()
{
    gl_Position = (pc.projection * pc.modelView) * vec4(osg_Vertex, 1.0);
    worldPos = vec4(pc.modelView * vec4(osg_Vertex, 1.0)).xyz;

    vec3 n = (pc.modelView * vec4(osg_Normal, 0.0)).xyz;
    normalDir = n;
    vec4 lpos = /*osg_LightSource.position*/ vec4(0.0, 0.25, 1.0, 0.0);
    viewDir = -vec3(pc.modelView * vec4(osg_Vertex, 1.0));

    if (lpos.w == 0.0)
        lightDir = lpos.xyz;
    else
        lightDir = lpos.xyz + viewDir;

    texCoord0 = osg_TexCoord0 * vec2(1,1);
}
"
                  SPIRVSize 0
                  SPIRV
                }
                NumSpecializationConstants 0
              }
              ShaderStage id=119 vsg::ShaderStage
              {
                NumUserObjects 0
                Stage 16
                EntryPoint "main"
                ShaderModule id=120 vsg::ShaderModule
                {
                  NumUserObjects 0
                  Source "#version 450
#pragma import_defines (VSG_DIFFUSE_MAP, VSG_EMISSIVE_MAP, VSG_LIGHTMAP_MAP, VSG_NORMAL_MAP, VSG_METALLROUGHNESS_MAP, VSG_SPECULAR_MAP, VSG_TWOSIDED, VSG_WORKFLOW_SPECGLOSS)
#define VSG_TWOSIDED

#extension GL_ARB_separate_shader_objects : enable

const float PI = 3.14159265359;
const float RECIPROCAL_PI = 0.31830988618;
const float RECIPROCAL_PI2 = 0.15915494;
const float EPSILON = 1e-6;
const float c_MinRoughness = 0.04;

#ifdef VSG_DIFFUSE_MAP
layout(binding = 0) uniform sampler2D diffuseMap;
#endif

#ifdef VSG_METALLROUGHNESS_MAP
layout(binding = 1) uniform sampler2D mrMap;
#endif

#ifdef VSG_NORMAL_MAP
layout(binding = 2) uniform sampler2D normalMap;
#endif

#ifdef VSG_LIGHTMAP_MAP
layout(binding = 3) uniform sampler2D aoMap;
#endif

#ifdef VSG_EMISSIVE_MAP
layout(binding = 4) uniform sampler2D emissiveMap;
#endif

#ifdef VSG_SPECULAR_MAP
layout(binding = 5) uniform sampler2D specularMap;
#endif

layout(push_constant) uniform PushConstants {
    mat4 projection;
    mat4 modelView;
} pc;

layout(binding = 10) uniform PbrData
{
    vec4 baseColorFactor;
    vec4 emissiveFactor;
    vec4 diffuseFactor;
    vec4 specularFactor;
    float metallicFactor;
    float roughnessFactor;
    float alphaMask;
    float alphaMaskCutoff;
} pbr;

layout(location = 0) in vec3 worldPos;
layout(location = 1) in vec3 normalDir;
layout(location = 2) in vec2 texCoord0;
layout(location = 5) in vec3 viewDir;
layout(location = 6) in vec3 lightDir;

layout(location = 0) out vec4 outColor;


// Encapsulate the various inputs used by the various functions in the shading equation
// We store values in this struct to simplify the integration of alternative implementations
// of the shading terms, outlined in the Readme.MD Appendix.
struct PBRInfo
{
    float NdotL;                  // cos angle between normal and light direction
    float NdotV;                  // cos angle between normal and view direction
    float NdotH;                  // cos angle between normal and half vector
    float LdotH;                  // cos angle between light direction and half vector
    float VdotH;                  // cos angle between view direction and half vector
    float VdotL;                  // cos angle between view direction and light direction
    float perceptualRoughness;    // roughness value, as authored by the model creator (input to shader)
    float metalness;              // metallic value at the surface
    vec3 reflectance0;            // full reflectance color (normal incidence angle)
    vec3 reflectance90;           // reflectance color at grazing angle
    float alphaRoughness;         // roughness mapped to a more linear change in the roughness (proposed by [2])
    vec3 diffuseColor;            // color contribution from diffuse lighting
    vec3 specularColor;           // color contribution from specular lighting
};


vec4 SRGBtoLINEAR(vec4 srgbIn)
{
    vec3 linOut = pow(srgbIn.xyz, vec3(2.2));
    return vec4(linOut,srgbIn.w);
}

vec4 LINEARtoSRGB(vec4 srgbIn)
{
    vec3 linOut = pow(srgbIn.xyz, vec3(1.0 / 2.2));
    return vec4(linOut, srgbIn.w);
}

float rcp(const in float value)
{
    return 1.0 / value;
}

float pow5(const in float value)
{
    return value * value * value * value * value;
}

// Find the normal for this fragment, pulling either from a predefined normal map
// or from the interpolated mesh normal and tangent attributes.
vec3 getNormal()
{
#ifdef VSG_NORMAL_MAP
    // Perturb normal, see http://www.thetenthplanet.de/archives/1180
    vec3 tangentNormal = texture(normalMap, texCoord0).xyz * 2.0 - 1.0;

    //tangentNormal *= vec3(2,2,1);

    vec3 q1 = dFdx(worldPos);
    vec3 q2 = dFdy(worldPos);
    vec2 st1 = dFdx(texCoord0);
    vec2 st2 = dFdy(texCoord0);

    vec3 N = normalize(normalDir);
    vec3 T = normalize(q1 * st2.t - q2 * st1.t);
    vec3 B = -normalize(cross(N, T));
    mat3 TBN = mat3(T, B, N);

    return normalize(TBN * tangentNormal);
#else
    return normalize(normalDir);
#endif
}

// Basic Lambertian diffuse
// Implementation from Lambert's Photometria https://archive.org/details/lambertsphotome00lambgoog
// See also [1], Equation 1
vec3 BRDF_Diffuse_Lambert(PBRInfo pbrInputs)
{
    return pbrInputs.diffuseColor * RECIPROCAL_PI;
}

vec3 BRDF_Diffuse_Custom_Lambert(PBRInfo pbrInputs)
{
    return pbrInputs.diffuseColor * RECIPROCAL_PI * pow(pbrInputs.NdotV, 0.5 + 0.3 * pbrInputs.perceptualRoughness);
}

// [Gotanda 2012, \"Beyond a Simple Physically Based Blinn-Phong Model in Real-Time\"]
vec3 BRDF_Diffuse_OrenNayar(PBRInfo pbrInputs)
{
    float a = pbrInputs.alphaRoughness;
    float s = a;// / ( 1.29 + 0.5 * a );
    float s2 = s * s;
    float VoL = 2 * pbrInputs.VdotH * pbrInputs.VdotH - 1;		// double angle identity
    float Cosri = pbrInputs.VdotL - pbrInputs.NdotV * pbrInputs.NdotL;
    float C1 = 1 - 0.5 * s2 / (s2 + 0.33);
    float C2 = 0.45 * s2 / (s2 + 0.09) * Cosri * ( Cosri >= 0 ? 1.0 / max(pbrInputs.NdotL, pbrInputs.NdotV) : 1 );
    return pbrInputs.diffuseColor / PI * ( C1 + C2 ) * ( 1 + pbrInputs.perceptualRoughness * 0.5 );
}

// [Gotanda 2014, \"Designing Reflectance Models for New Consoles\"]
vec3 BRDF_Diffuse_Gotanda(PBRInfo pbrInputs)
{
    float a = pbrInputs.alphaRoughness;
    float a2 = a * a;
    float F0 = 0.04;
    float VoL = 2 * pbrInputs.VdotH * pbrInputs.VdotH - 1;		// double angle identity
    float Cosri = VoL - pbrInputs.NdotV * pbrInputs.NdotL;
    float a2_13 = a2 + 1.36053;
    float Fr = ( 1 - ( 0.542026*a2 + 0.303573*a ) / a2_13 ) * ( 1 - pow( 1 - pbrInputs.NdotV, 5 - 4*a2 ) / a2_13 ) * ( ( -0.733996*a2*a + 1.50912*a2 - 1.16402*a ) * pow( 1 - pbrInputs.NdotV, 1 + rcp(39*a2*a2+1) ) + 1 );
    //float Fr = ( 1 - 0.36 * a ) * ( 1 - pow( 1 - NoV, 5 - 4*a2 ) / a2_13 ) * ( -2.5 * Roughness * ( 1 - NoV ) + 1 );
    float Lm = ( max( 1 - 2*a, 0 ) * ( 1 - pow5( 1 - pbrInputs.NdotL ) ) + min( 2*a, 1 ) ) * ( 1 - 0.5*a * (pbrInputs.NdotL - 1) ) * pbrInputs.NdotL;
    float Vd = ( a2 / ( (a2 + 0.09) * (1.31072 + 0.995584 * pbrInputs.NdotV) ) ) * ( 1 - pow( 1 - pbrInputs.NdotL, ( 1 - 0.3726732 * pbrInputs.NdotV * pbrInputs.NdotV ) / ( 0.188566 + 0.38841 * pbrInputs.NdotV ) ) );
    float Bp = Cosri < 0 ? 1.4 * pbrInputs.NdotV * pbrInputs.NdotL * Cosri : Cosri;
    float Lr = (21.0 / 20.0) * (1 - F0) * ( Fr * Lm + Vd + Bp );
    return pbrInputs.diffuseColor * RECIPROCAL_PI * Lr;
}

vec3 BRDF_Diffuse_Burley(PBRInfo pbrInputs)
{
    float energyBias = mix(pbrInputs.perceptualRoughness, 0.0, 0.5);
    float energyFactor = mix(pbrInputs.perceptualRoughness, 1.0, 1.0 / 1.51);
    float fd90 = energyBias + 2.0 * pbrInputs.VdotH * pbrInputs.VdotH * pbrInputs.perceptualRoughness;
    float f0 = 1.0;
    float lightScatter = f0 + (fd90 - f0) * pow(1.0 - pbrInputs.NdotL, 5.0);
    float viewScatter = f0 + (fd90 - f0) * pow(1.0 - pbrInputs.NdotV, 5.0);

    return pbrInputs.diffuseColor * lightScatter * viewScatter * energyFactor;
}

vec3 BRDF_Diffuse_Disney(PBRInfo pbrInputs)
{
	float Fd90 = 0.5 + 2.0 * pbrInputs.perceptualRoughness * pbrInputs.VdotH * pbrInputs.VdotH;
    vec3 f0 = vec3(0.1);
	vec3 invF0 = vec3(1.0, 1.0, 1.0) - f0;
	float dim = min(invF0.r, min(invF0.g, invF0.b));
	float result = ((1.0 + (Fd90 - 1.0) * pow(1.0 - pbrInputs.NdotL, 5.0 )) * (1.0 + (Fd90 - 1.0) * pow(1.0 - pbrInputs.NdotV, 5.0 ))) * dim;
	return pbrInputs.diffuseColor * result;
}

// The following equation models the Fresnel reflectance term of the spec equation (aka F())
// Implementation of fresnel from [4], Equation 15
vec3 specularReflection(PBRInfo pbrInputs)
{
    //return pbrInputs.reflectance0 + (pbrInputs.reflectance90 - pbrInputs.reflectance0) * pow(clamp(1.0 - pbrInputs.VdotH, 0.0, 1.0), 5.0);
    return pbrInputs.reflectance0 + (pbrInputs.reflectance90 - pbrInputs.reflectance90*pbrInputs.reflectance0) * exp2((-5.55473 * pbrInputs.VdotH - 6.98316) * pbrInputs.VdotH);
}

// This calculates the specular geometric attenuation (aka G()),
// where rougher material will reflect less light back to the viewer.
// This implementation is based on [1] Equation 4, and we adopt their modifications to
// alphaRoughness as input as originally proposed in [2].
float geometricOcclusion(PBRInfo pbrInputs)
{
    float NdotL = pbrInputs.NdotL;
    float NdotV = pbrInputs.NdotV;
    float r = pbrInputs.alphaRoughness * pbrInputs.alphaRoughness;

    float attenuationL = 2.0 * NdotL / (NdotL + sqrt(r + (1.0 - r) * (NdotL * NdotL)));
    float attenuationV = 2.0 * NdotV / (NdotV + sqrt(r + (1.0 - r) * (NdotV * NdotV)));
    return attenuationL * attenuationV;
}

// The following equation(s) model the distribution of microfacet normals across the area being drawn (aka D())
// Implementation from \"Average Irregularity Representation of a Roughened Surface for Ray Reflection\" by T. S. Trowbridge, and K. P. Reitz
// Follows the distribution function recommended in the SIGGRAPH 2013 course notes from EPIC Games [1], Equation 3.
float microfacetDistribution(PBRInfo pbrInputs)
{
    float roughnessSq = pbrInputs.alphaRoughness * pbrInputs.alphaRoughness;
    float f = (pbrInputs.NdotH * roughnessSq - pbrInputs.NdotH) * pbrInputs.NdotH + 1.0;
    return roughnessSq / (PI * f * f);
}

vec3 BRDF(vec3 v, vec3 n, vec3 l, vec3 h, float perceptualRoughness, float metallic, vec3 specularEnvironmentR0, vec3 specularEnvironmentR90, float alphaRoughness, vec3 diffuseColor, vec3 specularColor, float ao)
{
    vec3 reflection = -normalize(reflect(v, n));
    reflection.y *= -1.0f;

    float NdotL = clamp(dot(n, l), 0.001, 1.0);
    float NdotV = clamp(abs(dot(n, v)), 0.001, 1.0);
    float NdotH = clamp(dot(n, h), 0.0, 1.0);
    float LdotH = clamp(dot(l, h), 0.0, 1.0);
    float VdotH = clamp(dot(v, h), 0.0, 1.0);
    float VdotL = clamp(dot(v, l), 0.0, 1.0);

    PBRInfo pbrInputs = PBRInfo(NdotL,
                                NdotV,
                                NdotH,
                                LdotH,
                                VdotH,
                                VdotL,
                                perceptualRoughness,
                                metallic,
                                specularEnvironmentR0,
                                specularEnvironmentR90,
                                alphaRoughness,
                                diffuseColor,
                                specularColor);

    // Calculate the shading terms for the microfacet specular shading model
    vec3 F = specularReflection(pbrInputs);
    float G = geometricOcclusion(pbrInputs);
    float D = microfacetDistribution(pbrInputs);

    const vec3 u_LightColor = vec3(1.0);

    // Calculation of analytical lighting contribution
    vec3 diffuseContrib = (1.0 - F) * BRDF_Diffuse_Disney(pbrInputs);
    vec3 specContrib = F * G * D / (4.0 * NdotL * NdotV);
    // Obtain final intensity as reflectance (BRDF) scaled by the energy of the light (cosine law)
    vec3 color = NdotL * u_LightColor * (diffuseContrib + specContrib);

    color *= ao;

#ifdef VSG_EMISSIVE_MAP
    vec3 emissive = SRGBtoLINEAR(texture(emissiveMap, texCoord0)).rgb * pbr.emissiveFactor.rgb;
#else
    vec3 emissive = pbr.emissiveFactor.rgb;
#endif
    color += emissive;

    return color;
}

float convertMetallic(vec3 diffuse, vec3 specular, float maxSpecular)
{
    float perceivedDiffuse = sqrt(0.299 * diffuse.r * diffuse.r + 0.587 * diffuse.g * diffuse.g + 0.114 * diffuse.b * diffuse.b);
    float perceivedSpecular = sqrt(0.299 * specular.r * specular.r + 0.587 * specular.g * specular.g + 0.114 * specular.b * specular.b);

    if (perceivedSpecular < c_MinRoughness)
    {
        return 0.0;
    }

    float a = c_MinRoughness;
    float b = perceivedDiffuse * (1.0 - maxSpecular) / (1.0 - c_MinRoughness) + perceivedSpecular - 2.0 * c_MinRoughness;
    float c = c_MinRoughness - perceivedSpecular;
    float D = max(b * b - 4.0 * a * c, 0.0);
    return clamp((-b + sqrt(D)) / (2.0 * a), 0.0, 1.0);
}

void main()
{
    float perceptualRoughness = 0.0;
    float metallic;
    vec3 diffuseColor;
    vec4 baseColor;

    float ambientOcclusion = 1.0;

    vec3 f0 = vec3(0.04);

#ifdef VSG_DIFFUSE_MAP
    baseColor = SRGBtoLINEAR(texture(diffuseMap, texCoord0)) * pbr.baseColorFactor;
#else
    baseColor = pbr.baseColorFactor;
#endif

    if (pbr.alphaMask == 1.0f)
    {
        if (baseColor.a < pbr.alphaMaskCutoff)
            discard;
    }


#ifdef VSG_WORKFLOW_SPECGLOSS
    #ifdef VSG_SPECULAR_MAP
        vec3 specular = SRGBtoLINEAR(texture(specularMap, texCoord0)).rgb;
        perceptualRoughness = 1.0 - texture(specularMap, texCoord0).a;
    #else
        vec3 specular = vec3(0.0);
        perceptualRoughness = 0.0;
    #endif

        const float epsilon = 1e-6;

    #ifdef VSG_DIFFUSE_MAP
        vec4 diffuse = SRGBtoLINEAR(texture(diffuseMap, texCoord0));
    #else
        vec4 diffuse = vec4(1.0);
    #endif

        float maxSpecular = max(max(specular.r, specular.g), specular.b);

        // Convert metallic value from specular glossiness inputs
        metallic = convertMetallic(diffuse.rgb, specular, maxSpecular);

        vec3 baseColorDiffusePart = diffuse.rgb * ((1.0 - maxSpecular) / (1 - c_MinRoughness) / max(1 - metallic, epsilon)) * pbr.diffuseFactor.rgb;
        vec3 baseColorSpecularPart = specular - (vec3(c_MinRoughness) * (1 - metallic) * (1 / max(metallic, epsilon))) * pbr.specularFactor.rgb;
        baseColor = vec4(mix(baseColorDiffusePart, baseColorSpecularPart, metallic * metallic), diffuse.a);
#else
        perceptualRoughness = pbr.roughnessFactor;
        metallic = pbr.metallicFactor;

    #ifdef VSG_METALLROUGHNESS_MAP
        vec4 mrSample = texture(mrMap, texCoord0);
        perceptualRoughness = mrSample.g * perceptualRoughness;
        metallic = mrSample.b * metallic;
    #endif
#endif

#ifdef VSG_LIGHTMAP_MAP
    ambientOcclusion = texture(aoMap, texCoord0).r;
#endif

    diffuseColor = baseColor.rgb * (vec3(1.0) - f0);
    diffuseColor *= 1.0 - metallic;

    float alphaRoughness = perceptualRoughness * perceptualRoughness;

    vec3 specularColor = mix(f0, baseColor.rgb, metallic);

    // Compute reflectance.
    float reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);

    // For typical incident reflectance range (between 4% to 100%) set the grazing reflectance to 100% for typical fresnel effect.
    // For very low reflectance range on highly diffuse objects (below 4%), incrementally reduce grazing reflecance to 0%.
    float reflectance90 = clamp(reflectance * 25.0, 0.0, 1.0);
    vec3 specularEnvironmentR0 = specularColor.rgb;
    vec3 specularEnvironmentR90 = vec3(1.0, 1.0, 1.0) * reflectance90;

    vec3 n = getNormal();
    vec3 v = normalize(viewDir);    // Vector from surface point to camera
    vec3 l = normalize(lightDir);     // Vector from surface point to light
    vec3 h = normalize(l+v);                        // Half vector between both l and v

    vec3 colorFrontFace = BRDF(v, n, l, h, perceptualRoughness, metallic, specularEnvironmentR0, specularEnvironmentR90, alphaRoughness, diffuseColor, specularColor, ambientOcclusion);
#ifdef VSG_TWOSIDED
    vec3 colorBackFace = BRDF(v, -n, l, h, perceptualRoughness, metallic, specularEnvironmentR0, specularEnvironmentR90, alphaRoughness, diffuseColor, specularColor, ambientOcclusion);
    vec3 color = colorFrontFace+colorBackFace;
#else
    vec3 color = colorFrontFace;
#endif

    outColor = LINEARtoSRGB(vec4(color, baseColor.a));
}
"
                  SPIRVSize 0
                  SPIRV
                }
                NumSpecializationConstants 0
              }
              NumPipelineStates 6
              PipelineState id=121 vsg::VertexInputState
              {
                NumUserObjects 0
                NumBindings 3
                binding 0
                stride 12
                inputRate 0
                binding 1
                stride 12
                inputRate 0
                binding 2
                stride 8
                inputRate 0
                NumAttributes 3
                location 0
                binding 0
                format 106
                offset 0
                location 1
                binding 1
                format 106
                offset 0
                location 2
                binding 2
                format 103
                offset 0
              }
              PipelineState id=122 vsg::InputAssemblyState
              {
                NumUserObjects 0
                topology 3
                primitiveRestartEnable 0
              }
              PipelineState id=123 vsg::RasterizationState
              {
                NumUserObjects 0
                depthClampEnable 0
                rasterizerDiscardEnable 0
                polygonMode 0
                cullMode 0
                frontFace 0
                depthBiasEnable 0
                depthBiasConstantFactor 1
                depthBiasClamp 0
                depthBiasSlopeFactor 1
                lineWidth 1
              }
              PipelineState id=124 vsg::MultisampleState
              {
                NumUserObjects 0
                rasterizationSamples 1
                sampleShadingEnable 0
                minSampleShading 0
                NumSampleMask 0
                alphaToCoverageEnable 0
                alphaToOneEnable 0
              }
              PipelineState id=125 vsg::ColorBlendState
              {
                NumUserObjects 0
                logicOp 3
                logicOpEnable 0
                NumColorBlendAttachments 1
                blendEnable 0
                srcColorBlendFactor 6
                dstColorBlendFactor 7
                colorBlendOp 0
                srcAlphaBlendFactor 6
                dstAlphaBlendFactor 7
                alphaBlendOp 1
                colorWriteMask 15
                blendConstants 0 0 0 0
              }
              PipelineState id=126 vsg::DepthStencilState
              {
                NumUserObjects 0
                depthTestEnable 1
                depthWriteEnable 1
                depthCompareOp 1
                depthBoundsTestEnable 0
                stencilTestEnable 0
                front.failOp 0
                front.passOp 0
                front.depthFailOp 0
                front.compareOp 0
                front.compareMask 0
                front.writeMask 0
                front.reference 0
                back.failOp 0
                back.passOp 0
                back.depthFailOp 0
                back.compareOp 0
                back.compareMask 0
                back.writeMask 0
                back.reference 0
                minDepthBounds 0
                maxDepthBounds 1
              }
              subpass 0
            }
          }
          StateCommand id=127 vsg::BindDescriptorSet
          {
            NumUserObjects 0
            Slot 1
            PipelineLayout id=115
            firstSet 0
            DescriptorSet id=128 vsg::DescriptorSet
            {
              NumUserObjects 0
              DescriptorSetLayout id=116
              NumDescriptors 1
              Descriptor id=129 vsg::DescriptorBuffer
              {
                NumUserObjects 0
                DstBinding 10
                DstArrayElement 0
                NumData 1
                Data id=130 vsg::ubyteArray
                {
                  NumUserObjects 0
                  Layout 0 1 0 1 1 1 0 -1
                  Size 80
                  Storage id=0
                  Data 0 0 0 0 0 0 0 0 0 0 0 0
                   0 0 128 63 0 0 0 0 0 0 0 0
                   0 0 0 0 0 0 128 63 0 0 128 63
                   0 0 128 63 0 0 128 63 0 0 128 63
                   0 0 0 0 0 0 0 0 0 0 0 0
                   0 0 128 63 0 0 0 0 205 204 204 62
                   0 0 128 63 0 0 0 63
                }
              }
            }
          }
        }
        Matrix 0.1 0 0 0 0 0.1 0 0 0 0 2 0
         2 1 2 1
        SubgraphRequiresLocalFrustum 1
      }
      Child id=131 vsg::MatrixTransform
      {
        NumUserObjects 0
        NumChildren 0
        Matrix 0.685921 0.727676 0 0 -0.324014 0.305421 0.895396 0 0.651558 -0.61417 0.445271 0
         7.35889 -6.92579 4.95831 1
        SubgraphRequiresLocalFrustum 1
      }
      Matrix 1 0 0 0 0 1 0 0 0 0 1 0
       0 0 0 1
      SubgraphRequiresLocalFrustum 1
    }
    NumStateCommands 2
    StateCommand id=132 vsg::BindGraphicsPipeline
    {
      NumUserObjects 0
      Slot 0
      GraphicsPipeline id=133 vsg::GraphicsPipeline
      {
        NumUserObjects 0
        PipelineLayout id=134 vsg::PipelineLayout
        {
          NumUserObjects 0
          Flags 0
          NumDescriptorSetLayouts 1
          DescriptorSetLayout id=135 vsg::DescriptorSetLayout
          {
            NumUserObjects 0
            NumDescriptorSetLayoutBindings 1
            binding 10
            descriptorType 6
            descriptorCount 1
            stageFlags 16
          }
          NumPushConstantRanges 1
          stageFlags 1
          offset 0
          size 128
        }
        NumShaderStages 2
        ShaderStage id=136 vsg::ShaderStage
        {
          NumUserObjects 0
          Stage 1
          EntryPoint "main"
          ShaderModule id=137 vsg::ShaderModule
          {
            NumUserObjects 0
            Source "#version 450

#extension GL_ARB_separate_shader_objects : enable

layout(push_constant) uniform PushConstants {
    mat4 projection;
    mat4 modelView;
} pc;

layout(location = 0) in vec3 osg_Vertex;
layout(location = 0) out vec3 worldPos;

layout(location = 1) in vec3 osg_Normal;
layout(location = 1) out vec3 normalDir;

layout(location = 2) in vec2 osg_TexCoord0;
layout(location = 2) out vec2 texCoord0;

layout(location = 5) out vec3 viewDir;
layout(location = 6) out vec3 lightDir;

out gl_PerVertex{ vec4 gl_Position; };

void main()
{
    gl_Position = (pc.projection * pc.modelView) * vec4(osg_Vertex, 1.0);
    worldPos = vec4(pc.modelView * vec4(osg_Vertex, 1.0)).xyz;

    vec3 n = (pc.modelView * vec4(osg_Normal, 0.0)).xyz;
    normalDir = n;
    vec4 lpos = /*osg_LightSource.position*/ vec4(0.0, 0.25, 1.0, 0.0);
    viewDir = -vec3(pc.modelView * vec4(osg_Vertex, 1.0));

    if (lpos.w == 0.0)
        lightDir = lpos.xyz;
    else
        lightDir = lpos.xyz + viewDir;

    texCoord0 = osg_TexCoord0 * vec2(1,1);
}
"
            SPIRVSize 0
            SPIRV
          }
          NumSpecializationConstants 0
        }
        ShaderStage id=138 vsg::ShaderStage
        {
          NumUserObjects 0
          Stage 16
          EntryPoint "main"
          ShaderModule id=139 vsg::ShaderModule
          {
            NumUserObjects 0
            Source "#version 450
#pragma import_defines (VSG_DIFFUSE_MAP, VSG_EMISSIVE_MAP, VSG_LIGHTMAP_MAP, VSG_NORMAL_MAP, VSG_SPECULAR_MAP, VSG_TWOSIDED)

#extension GL_ARB_separate_shader_objects : enable

#ifdef VSG_DIFFUSE_MAP
layout(binding = 0) uniform sampler2D diffuseMap;
#endif

#ifdef VSG_NORMAL_MAP
layout(binding = 2) uniform sampler2D normalMap;
#endif

#ifdef VSG_LIGHTMAP_MAP
layout(binding = 3) uniform sampler2D aoMap;
#endif

#ifdef VSG_EMISSIVE_MAP
layout(binding = 4) uniform sampler2D emissiveMap;
#endif

#ifdef VSG_SPECULAR_MAP
layout(binding = 5) uniform sampler2D specularMap;
#endif

layout(push_constant) uniform PushConstants {
    mat4 projection;
    mat4 modelView;
} pc;

layout(binding = 10) uniform MaterialData
{
    vec4 ambientColor;
    vec4 diffuseColor;
    vec4 specularColor;
    vec4 emissiveColor;
    float shininess;
    float alphaMask;
    float alphaMaskCutoff;
} material;

layout(location = 0) in vec3 worldPos;
layout(location = 1) in vec3 normalDir;
layout(location = 2) in vec2 texCoord0;
layout(location = 5) in vec3 viewDir;
layout(location = 6) in vec3 lightDir;

layout(location = 0) out vec4 outColor;

// Find the normal for this fragment, pulling either from a predefined normal map
// or from the interpolated mesh normal and tangent attributes.
vec3 getNormal()
{
#ifdef VSG_NORMAL_MAP
    // Perturb normal, see http://www.thetenthplanet.de/archives/1180
    vec3 tangentNormal = texture(normalMap, texCoord0).xyz * 2.0 - 1.0;

    //tangentNormal *= vec3(2,2,1);

    vec3 q1 = dFdx(worldPos);
    vec3 q2 = dFdy(worldPos);
    vec2 st1 = dFdx(texCoord0);
    vec2 st2 = dFdy(texCoord0);

    vec3 N = normalize(normalDir);
    vec3 T = normalize(q1 * st2.t - q2 * st1.t);
    vec3 B = -normalize(cross(N, T));
    mat3 TBN = mat3(T, B, N);

    return normalize(TBN * tangentNormal);
#else
    return normalize(normalDir);
#endif
}

vec3 computeLighting(vec3 ambientColor, vec3 diffuseColor, vec3 specularColor, vec3 emissiveColor, float shininess, float ambientOcclusion, vec3 ld, vec3 nd, vec3 vd)
{
    vec3 color = vec3(0.0);
    color.rgb += ambientColor;

    float diff = max(dot(ld, nd), 0.0);
    color.rgb += diffuseColor * diff;

    if (diff > 0.0)
    {
        vec3 halfDir = normalize(ld + vd);
        color.rgb += specularColor * pow(max(dot(halfDir, nd), 0.0), shininess);
    }

    vec3 result = color + emissiveColor;
    result *= ambientOcclusion;

    return result;
}

void main()
{
    vec4 ambientColor = material.ambientColor;
    vec4 diffuseColor = material.diffuseColor;
    vec4 specularColor = material.specularColor;
    vec4 emissiveColor = material.emissiveColor;
    float shininess = material.shininess;
    float ambientOcclusion = 1.0;

#ifdef VSG_DIFFUSE_MAP
    diffuseColor *= texture(diffuseMap, texCoord0.st);
#endif

    if (material.alphaMask == 1.0f)
    {
        if (diffuseColor.a < material.alphaMaskCutoff)
            discard;
    }

#ifdef VSG_EMISSIVE_MAP
    emissiveColor *= texture(emissiveMap, texCoord0.st);
#endif

#ifdef VSG_LIGHTMAP_MAP
    ambientOcclusion *= texture(aoMap, texCoord0.st).r;
#endif

#ifdef VSG_SPECULAR_MAP
    specularColor *= texture(specularMap, texCoord0.st);
#endif

    vec3 nd = getNormal();
    vec3 ld = normalize(lightDir);
    vec3 vd = normalize(viewDir);

    vec3 colorFrontFace = computeLighting(ambientColor.rgb, diffuseColor.rgb, specularColor.rgb, emissiveColor.rgb, shininess, ambientOcclusion, ld, nd, vd);
#ifdef VSG_TWOSIDED
    vec3 colorBackFace = computeLighting(ambientColor.rgb, diffuseColor.rgb, specularColor.rgb, emissiveColor.rgb, shininess, ambientOcclusion, ld, -nd, vd);
    outColor.rgb = colorFrontFace + colorBackFace;
#else
    outColor.rgb = colorFrontFace;
#endif
    outColor.a = diffuseColor.a;
}
"
            SPIRVSize 0
            SPIRV
          }
          NumSpecializationConstants 0
        }
        NumPipelineStates 6
        PipelineState id=140 vsg::VertexInputState
        {
          NumUserObjects 0
          NumBindings 3
          binding 0
          stride 12
          inputRate 0
          binding 1
          stride 12
          inputRate 0
          binding 2
          stride 8
          inputRate 0
          NumAttributes 3
          location 0
          binding 0
          format 106
          offset 0
          location 1
          binding 1
          format 106
          offset 0
          location 2
          binding 2
          format 103
          offset 0
        }
        PipelineState id=141 vsg::InputAssemblyState
        {
          NumUserObjects 0
          topology 3
          primitiveRestartEnable 0
        }
        PipelineState id=142 vsg::RasterizationState
        {
          NumUserObjects 0
          depthClampEnable 0
          rasterizerDiscardEnable 0
          polygonMode 0
          cullMode 2
          frontFace 0
          depthBiasEnable 0
          depthBiasConstantFactor 1
          depthBiasClamp 0
          depthBiasSlopeFactor 1
          lineWidth 1
        }
        PipelineState id=143 vsg::MultisampleState
        {
          NumUserObjects 0
          rasterizationSamples 1
          sampleShadingEnable 0
          minSampleShading 0
          NumSampleMask 0
          alphaToCoverageEnable 0
          alphaToOneEnable 0
        }
        PipelineState id=144 vsg::ColorBlendState
        {
          NumUserObjects 0
          logicOp 3
          logicOpEnable 0
          NumColorBlendAttachments 1
          blendEnable 0
          srcColorBlendFactor 6
          dstColorBlendFactor 7
          colorBlendOp 0
          srcAlphaBlendFactor 6
          dstAlphaBlendFactor 7
          alphaBlendOp 1
          colorWriteMask 15
          blendConstants 0 0 0 0
        }
        PipelineState id=145 vsg::DepthStencilState
        {
          NumUserObjects 0
          depthTestEnable 1
          depthWriteEnable 1
          depthCompareOp 1
          depthBoundsTestEnable 0
          stencilTestEnable 0
          front.failOp 0
          front.passOp 0
          front.depthFailOp 0
          front.compareOp 0
          front.compareMask 0
          front.writeMask 0
          front.reference 0
          back.failOp 0
          back.passOp 0
          back.depthFailOp 0
          back.compareOp 0
          back.compareMask 0
          back.writeMask 0
          back.reference 0
          minDepthBounds 0
          maxDepthBounds 1
        }
        subpass 0
      }
    }
    StateCommand id=146 vsg::BindDescriptorSet
    {
      NumUserObjects 0
      Slot 1
      PipelineLayout id=134
      firstSet 0
      DescriptorSet id=147 vsg::DescriptorSet
      {
        NumUserObjects 0
        DescriptorSetLayout id=135
        NumDescriptors 1
        Descriptor id=148 vsg::DescriptorBuffer
        {
          NumUserObjects 0
          DstBinding 10
          DstArrayElement 0
          NumData 1
          Data id=149 vsg::ubyteArray
          {
            NumUserObjects 0
            Layout 0 1 0 1 1 1 0 -1
            Size 76
            Storage id=0
            Data 0 0 0 0 0 0 0 0 0 0 0 0
             0 0 128 63 0 0 128 63 0 0 128 63
             0 0 128 63 0 0 128 63 0 0 0 0
             0 0 0 0 0 0 0 0 0 0 128 63
             0 0 0 0 0 0 0 0 0 0 0 0
             0 0 128 63 0 0 0 0 0 0 128 63
             0 0 0 63
          }
        }
      }
    }
  }
  Matrix 1 0 0 0 0 6.12323e-17 1 0 0 -1 6.12323e-17 0
   0 0 0 1
  SubgraphRequiresLocalFrustum 1
}
