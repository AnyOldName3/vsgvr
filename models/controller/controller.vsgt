#vsga 0.1.2
Root id=1 vsg::MatrixTransform
{
  NumUserObjects 0
  NumChildren 1
  Child id=2 vsg::StateGroup
  {
    NumUserObjects 0
    NumChildren 1
    Child id=3 vsg::MatrixTransform
    {
      NumUserObjects 0
      NumChildren 3
      Child id=4 vsg::MatrixTransform
      {
        NumUserObjects 0
        NumChildren 1
        Child id=5 vsg::MatrixTransform
        {
          NumUserObjects 0
          NumChildren 0
          Matrix 1 0 0 0 0 5.96046e-08 -1 0 0 1 5.96046e-08 0
           0 0 0 1
          SubgraphRequiresLocalFrustum 1
        }
        Matrix -0.290865 -0.0551891 -0.955171 0 0.566393 0.794672 -0.218391 0 0.771101 -0.604525 -0.199883 0
         0 0 0.0200351 1
        SubgraphRequiresLocalFrustum 1
      }
      Child id=6 vsg::MatrixTransform
      {
        NumUserObjects 0
        NumChildren 1
        Child id=7 vsg::StateGroup
        {
          NumUserObjects 0
          NumChildren 1
          Child id=8 vsg::VertexIndexDraw
          {
            NumUserObjects 0
            firstBinding 0
            NumArrays 3
            Array id=9 vsg::vec3Array
            {
              NumUserObjects 0
              Layout 0 12 0 1 1 1 0 -1
              Size 40
              Storage id=0
              Data 1 -1 -1 1 -1 -1 1 -1 -1 1 -1 1
               1 -1 1 1 -1 1 -1 -1 -1 -1 -1 -1
               -1 -1 -1 -1 -1 1 -1 -1 1 -1 -1 1
               0.611511 1 -0.611511 0.611511 1 -0.611511 0.611511 1 -0.611511 1 0.611511 -1
               1 0.611511 -1 1 0.611511 -1 1 0.611511 -1 0.611511 1 0.611511
               0.611511 1 0.611511 0.611511 1 0.611511 1 0.611511 1 1 0.611511 1
               1 0.611511 1 1 0.611511 1 -0.611511 1 -0.611511 -0.611511 1 -0.611511
               -0.611511 1 -0.611511 -1 0.611511 -1 -1 0.611511 -1 -1 0.611511 -1
               -1 0.611511 -1 -0.611511 1 0.611511 -0.611511 1 0.611511 -0.611511 1 0.611511
               -1 0.611511 1 -1 0.611511 1 -1 0.611511 1 -1 0.611511 1
            }
            Array id=10 vsg::vec3Array
            {
              NumUserObjects 0
              Layout 0 12 0 1 1 1 0 -1
              Size 40
              Storage id=0
              Data 0 -1 -0 0 0 -1 1 0 -0 0 -1 -0
               0 0 1 1 0 -0 -1 0 -0 0 -1 -0
               0 0 -1 -1 0 -0 0 -1 -0 0 0 1
               0 0.707107 -0.707107 0 1 -0 0.707107 0.707107 -0 0 0 -1
               0 0.707107 -0.707107 0.707107 0.707107 -0 1 0 -0 0 0.707107 0.707107
               0 1 -0 0.707107 0.707107 -0 0 0 1 0 0.707107 0.707107
               0.707107 0.707107 -0 1 0 -0 -0.707107 0.707107 -0 0 0.707107 -0.707107
               0 1 -0 -1 0 -0 -0.707107 0.707107 -0 0 0 -1
               0 0.707107 -0.707107 -0.707107 0.707107 -0 0 0.707107 0.707107 0 1 -0
               -1 0 -0 -0.707107 0.707107 -0 0 0 1 0 0.707107 0.707107
            }
            Array id=11 vsg::vec2Array
            {
              NumUserObjects 0
              Layout 0 8 0 1 1 1 0 -1
              Size 40
              Storage id=0
              Data 0.375 0.5 0.375 0.5 0.375 0.5 0.375 0.25 0.375 0.25 0.375 0.25
               0.375 0.75 0.125 0.5 0.375 0.75 0.375 1 0.125 0.25 0.375 0
               0.673561 0.451439 0.673561 0.451439 0.673561 0.451439 0.576439 0.5 0.625 0.5 0.576439 0.5
               0.576439 0.5 0.673561 0.298561 0.673561 0.298561 0.673561 0.298561 0.576439 0.25 0.625 0.25
               0.576439 0.25 0.576439 0.25 0.826439 0.451439 0.826439 0.451439 0.826439 0.451439 0.576439 0.75
               0.875 0.5 0.576439 0.75 0.875 0.5 0.826439 0.298561 0.826439 0.298561 0.826439 0.298561
               0.576439 1 0.875 0.25 0.576439 0 0.875 0.25
            }
            Indices id=12 vsg::ushortArray
            {
              NumUserObjects 0
              Layout 0 2 0 1 1 1 0 -1
              Size 60
              Storage id=0
              Data 7 0 3 7 3 10 2 18 25 2 25 5
               4 22 38 4 38 11 9 29 6 9 36 29
               8 31 15 8 15 1 27 12 16 27 16 32
               13 28 35 13 35 20 14 21 24 14 24 17
               19 34 39 19 39 23 33 26 30 33 30 37
            }
            indexCount 60
            instanceCount 1
            firstIndex 0
            vertexOffset 0
            firstInstance 0
          }
          NumStateCommands 2
          StateCommand id=13 vsg::BindGraphicsPipeline
          {
            NumUserObjects 0
            Slot 0
            GraphicsPipeline id=14 vsg::GraphicsPipeline
            {
              NumUserObjects 0
              PipelineLayout id=15 vsg::PipelineLayout
              {
                NumUserObjects 0
                Flags 0
                NumDescriptorSetLayouts 1
                DescriptorSetLayout id=16 vsg::DescriptorSetLayout
                {
                  NumUserObjects 0
                  NumDescriptorSetLayoutBindings 1
                  binding 10
                  descriptorType 6
                  descriptorCount 1
                  stageFlags 16
                }
                NumPushConstantRanges 1
                stageFlags 1
                offset 0
                size 128
              }
              NumShaderStages 2
              ShaderStage id=17 vsg::ShaderStage
              {
                NumUserObjects 0
                Stage 1
                EntryPoint "main"
                ShaderModule id=18 vsg::ShaderModule
                {
                  NumUserObjects 0
                  Source "#version 450

#extension GL_ARB_separate_shader_objects : enable

layout(push_constant) uniform PushConstants {
    mat4 projection;
    mat4 modelView;
} pc;

layout(location = 0) in vec3 osg_Vertex;
layout(location = 0) out vec3 worldPos;

layout(location = 1) in vec3 osg_Normal;
layout(location = 1) out vec3 normalDir;

layout(location = 2) in vec2 osg_TexCoord0;
layout(location = 2) out vec2 texCoord0;

layout(location = 5) out vec3 viewDir;
layout(location = 6) out vec3 lightDir;

out gl_PerVertex{ vec4 gl_Position; };

void main()
{
    gl_Position = (pc.projection * pc.modelView) * vec4(osg_Vertex, 1.0);
    worldPos = vec4(pc.modelView * vec4(osg_Vertex, 1.0)).xyz;

    vec3 n = (pc.modelView * vec4(osg_Normal, 0.0)).xyz;
    normalDir = n;
    vec4 lpos = /*osg_LightSource.position*/ vec4(0.0, 0.25, 1.0, 0.0);
    viewDir = -vec3(pc.modelView * vec4(osg_Vertex, 1.0));

    if (lpos.w == 0.0)
        lightDir = lpos.xyz;
    else
        lightDir = lpos.xyz + viewDir;

    texCoord0 = osg_TexCoord0 * vec2(1,1);
}
"
                  SPIRVSize 0
                  SPIRV
                }
                NumSpecializationConstants 0
              }
              ShaderStage id=19 vsg::ShaderStage
              {
                NumUserObjects 0
                Stage 16
                EntryPoint "main"
                ShaderModule id=20 vsg::ShaderModule
                {
                  NumUserObjects 0
                  Source "#version 450
#pragma import_defines (VSG_DIFFUSE_MAP, VSG_EMISSIVE_MAP, VSG_LIGHTMAP_MAP, VSG_NORMAL_MAP, VSG_METALLROUGHNESS_MAP, VSG_SPECULAR_MAP, VSG_TWOSIDED, VSG_WORKFLOW_SPECGLOSS)
#define VSG_TWOSIDED

#extension GL_ARB_separate_shader_objects : enable

const float PI = 3.14159265359;
const float RECIPROCAL_PI = 0.31830988618;
const float RECIPROCAL_PI2 = 0.15915494;
const float EPSILON = 1e-6;
const float c_MinRoughness = 0.04;

#ifdef VSG_DIFFUSE_MAP
layout(binding = 0) uniform sampler2D diffuseMap;
#endif

#ifdef VSG_METALLROUGHNESS_MAP
layout(binding = 1) uniform sampler2D mrMap;
#endif

#ifdef VSG_NORMAL_MAP
layout(binding = 2) uniform sampler2D normalMap;
#endif

#ifdef VSG_LIGHTMAP_MAP
layout(binding = 3) uniform sampler2D aoMap;
#endif

#ifdef VSG_EMISSIVE_MAP
layout(binding = 4) uniform sampler2D emissiveMap;
#endif

#ifdef VSG_SPECULAR_MAP
layout(binding = 5) uniform sampler2D specularMap;
#endif

layout(push_constant) uniform PushConstants {
    mat4 projection;
    mat4 modelView;
} pc;

layout(binding = 10) uniform PbrData
{
    vec4 baseColorFactor;
    vec4 emissiveFactor;
    vec4 diffuseFactor;
    vec4 specularFactor;
    float metallicFactor;
    float roughnessFactor;
    float alphaMask;
    float alphaMaskCutoff;
} pbr;

layout(location = 0) in vec3 worldPos;
layout(location = 1) in vec3 normalDir;
layout(location = 2) in vec2 texCoord0;
layout(location = 5) in vec3 viewDir;
layout(location = 6) in vec3 lightDir;

layout(location = 0) out vec4 outColor;


// Encapsulate the various inputs used by the various functions in the shading equation
// We store values in this struct to simplify the integration of alternative implementations
// of the shading terms, outlined in the Readme.MD Appendix.
struct PBRInfo
{
    float NdotL;                  // cos angle between normal and light direction
    float NdotV;                  // cos angle between normal and view direction
    float NdotH;                  // cos angle between normal and half vector
    float LdotH;                  // cos angle between light direction and half vector
    float VdotH;                  // cos angle between view direction and half vector
    float VdotL;                  // cos angle between view direction and light direction
    float perceptualRoughness;    // roughness value, as authored by the model creator (input to shader)
    float metalness;              // metallic value at the surface
    vec3 reflectance0;            // full reflectance color (normal incidence angle)
    vec3 reflectance90;           // reflectance color at grazing angle
    float alphaRoughness;         // roughness mapped to a more linear change in the roughness (proposed by [2])
    vec3 diffuseColor;            // color contribution from diffuse lighting
    vec3 specularColor;           // color contribution from specular lighting
};


vec4 SRGBtoLINEAR(vec4 srgbIn)
{
    vec3 linOut = pow(srgbIn.xyz, vec3(2.2));
    return vec4(linOut,srgbIn.w);
}

vec4 LINEARtoSRGB(vec4 srgbIn)
{
    vec3 linOut = pow(srgbIn.xyz, vec3(1.0 / 2.2));
    return vec4(linOut, srgbIn.w);
}

float rcp(const in float value)
{
    return 1.0 / value;
}

float pow5(const in float value)
{
    return value * value * value * value * value;
}

// Find the normal for this fragment, pulling either from a predefined normal map
// or from the interpolated mesh normal and tangent attributes.
vec3 getNormal()
{
#ifdef VSG_NORMAL_MAP
    // Perturb normal, see http://www.thetenthplanet.de/archives/1180
    vec3 tangentNormal = texture(normalMap, texCoord0).xyz * 2.0 - 1.0;

    //tangentNormal *= vec3(2,2,1);

    vec3 q1 = dFdx(worldPos);
    vec3 q2 = dFdy(worldPos);
    vec2 st1 = dFdx(texCoord0);
    vec2 st2 = dFdy(texCoord0);

    vec3 N = normalize(normalDir);
    vec3 T = normalize(q1 * st2.t - q2 * st1.t);
    vec3 B = -normalize(cross(N, T));
    mat3 TBN = mat3(T, B, N);

    return normalize(TBN * tangentNormal);
#else
    return normalize(normalDir);
#endif
}

// Basic Lambertian diffuse
// Implementation from Lambert's Photometria https://archive.org/details/lambertsphotome00lambgoog
// See also [1], Equation 1
vec3 BRDF_Diffuse_Lambert(PBRInfo pbrInputs)
{
    return pbrInputs.diffuseColor * RECIPROCAL_PI;
}

vec3 BRDF_Diffuse_Custom_Lambert(PBRInfo pbrInputs)
{
    return pbrInputs.diffuseColor * RECIPROCAL_PI * pow(pbrInputs.NdotV, 0.5 + 0.3 * pbrInputs.perceptualRoughness);
}

// [Gotanda 2012, \"Beyond a Simple Physically Based Blinn-Phong Model in Real-Time\"]
vec3 BRDF_Diffuse_OrenNayar(PBRInfo pbrInputs)
{
    float a = pbrInputs.alphaRoughness;
    float s = a;// / ( 1.29 + 0.5 * a );
    float s2 = s * s;
    float VoL = 2 * pbrInputs.VdotH * pbrInputs.VdotH - 1;		// double angle identity
    float Cosri = pbrInputs.VdotL - pbrInputs.NdotV * pbrInputs.NdotL;
    float C1 = 1 - 0.5 * s2 / (s2 + 0.33);
    float C2 = 0.45 * s2 / (s2 + 0.09) * Cosri * ( Cosri >= 0 ? 1.0 / max(pbrInputs.NdotL, pbrInputs.NdotV) : 1 );
    return pbrInputs.diffuseColor / PI * ( C1 + C2 ) * ( 1 + pbrInputs.perceptualRoughness * 0.5 );
}

// [Gotanda 2014, \"Designing Reflectance Models for New Consoles\"]
vec3 BRDF_Diffuse_Gotanda(PBRInfo pbrInputs)
{
    float a = pbrInputs.alphaRoughness;
    float a2 = a * a;
    float F0 = 0.04;
    float VoL = 2 * pbrInputs.VdotH * pbrInputs.VdotH - 1;		// double angle identity
    float Cosri = VoL - pbrInputs.NdotV * pbrInputs.NdotL;
    float a2_13 = a2 + 1.36053;
    float Fr = ( 1 - ( 0.542026*a2 + 0.303573*a ) / a2_13 ) * ( 1 - pow( 1 - pbrInputs.NdotV, 5 - 4*a2 ) / a2_13 ) * ( ( -0.733996*a2*a + 1.50912*a2 - 1.16402*a ) * pow( 1 - pbrInputs.NdotV, 1 + rcp(39*a2*a2+1) ) + 1 );
    //float Fr = ( 1 - 0.36 * a ) * ( 1 - pow( 1 - NoV, 5 - 4*a2 ) / a2_13 ) * ( -2.5 * Roughness * ( 1 - NoV ) + 1 );
    float Lm = ( max( 1 - 2*a, 0 ) * ( 1 - pow5( 1 - pbrInputs.NdotL ) ) + min( 2*a, 1 ) ) * ( 1 - 0.5*a * (pbrInputs.NdotL - 1) ) * pbrInputs.NdotL;
    float Vd = ( a2 / ( (a2 + 0.09) * (1.31072 + 0.995584 * pbrInputs.NdotV) ) ) * ( 1 - pow( 1 - pbrInputs.NdotL, ( 1 - 0.3726732 * pbrInputs.NdotV * pbrInputs.NdotV ) / ( 0.188566 + 0.38841 * pbrInputs.NdotV ) ) );
    float Bp = Cosri < 0 ? 1.4 * pbrInputs.NdotV * pbrInputs.NdotL * Cosri : Cosri;
    float Lr = (21.0 / 20.0) * (1 - F0) * ( Fr * Lm + Vd + Bp );
    return pbrInputs.diffuseColor * RECIPROCAL_PI * Lr;
}

vec3 BRDF_Diffuse_Burley(PBRInfo pbrInputs)
{
    float energyBias = mix(pbrInputs.perceptualRoughness, 0.0, 0.5);
    float energyFactor = mix(pbrInputs.perceptualRoughness, 1.0, 1.0 / 1.51);
    float fd90 = energyBias + 2.0 * pbrInputs.VdotH * pbrInputs.VdotH * pbrInputs.perceptualRoughness;
    float f0 = 1.0;
    float lightScatter = f0 + (fd90 - f0) * pow(1.0 - pbrInputs.NdotL, 5.0);
    float viewScatter = f0 + (fd90 - f0) * pow(1.0 - pbrInputs.NdotV, 5.0);

    return pbrInputs.diffuseColor * lightScatter * viewScatter * energyFactor;
}

vec3 BRDF_Diffuse_Disney(PBRInfo pbrInputs)
{
	float Fd90 = 0.5 + 2.0 * pbrInputs.perceptualRoughness * pbrInputs.VdotH * pbrInputs.VdotH;
    vec3 f0 = vec3(0.1);
	vec3 invF0 = vec3(1.0, 1.0, 1.0) - f0;
	float dim = min(invF0.r, min(invF0.g, invF0.b));
	float result = ((1.0 + (Fd90 - 1.0) * pow(1.0 - pbrInputs.NdotL, 5.0 )) * (1.0 + (Fd90 - 1.0) * pow(1.0 - pbrInputs.NdotV, 5.0 ))) * dim;
	return pbrInputs.diffuseColor * result;
}

// The following equation models the Fresnel reflectance term of the spec equation (aka F())
// Implementation of fresnel from [4], Equation 15
vec3 specularReflection(PBRInfo pbrInputs)
{
    //return pbrInputs.reflectance0 + (pbrInputs.reflectance90 - pbrInputs.reflectance0) * pow(clamp(1.0 - pbrInputs.VdotH, 0.0, 1.0), 5.0);
    return pbrInputs.reflectance0 + (pbrInputs.reflectance90 - pbrInputs.reflectance90*pbrInputs.reflectance0) * exp2((-5.55473 * pbrInputs.VdotH - 6.98316) * pbrInputs.VdotH);
}

// This calculates the specular geometric attenuation (aka G()),
// where rougher material will reflect less light back to the viewer.
// This implementation is based on [1] Equation 4, and we adopt their modifications to
// alphaRoughness as input as originally proposed in [2].
float geometricOcclusion(PBRInfo pbrInputs)
{
    float NdotL = pbrInputs.NdotL;
    float NdotV = pbrInputs.NdotV;
    float r = pbrInputs.alphaRoughness * pbrInputs.alphaRoughness;

    float attenuationL = 2.0 * NdotL / (NdotL + sqrt(r + (1.0 - r) * (NdotL * NdotL)));
    float attenuationV = 2.0 * NdotV / (NdotV + sqrt(r + (1.0 - r) * (NdotV * NdotV)));
    return attenuationL * attenuationV;
}

// The following equation(s) model the distribution of microfacet normals across the area being drawn (aka D())
// Implementation from \"Average Irregularity Representation of a Roughened Surface for Ray Reflection\" by T. S. Trowbridge, and K. P. Reitz
// Follows the distribution function recommended in the SIGGRAPH 2013 course notes from EPIC Games [1], Equation 3.
float microfacetDistribution(PBRInfo pbrInputs)
{
    float roughnessSq = pbrInputs.alphaRoughness * pbrInputs.alphaRoughness;
    float f = (pbrInputs.NdotH * roughnessSq - pbrInputs.NdotH) * pbrInputs.NdotH + 1.0;
    return roughnessSq / (PI * f * f);
}

vec3 BRDF(vec3 v, vec3 n, vec3 l, vec3 h, float perceptualRoughness, float metallic, vec3 specularEnvironmentR0, vec3 specularEnvironmentR90, float alphaRoughness, vec3 diffuseColor, vec3 specularColor, float ao)
{
    vec3 reflection = -normalize(reflect(v, n));
    reflection.y *= -1.0f;

    float NdotL = clamp(dot(n, l), 0.001, 1.0);
    float NdotV = clamp(abs(dot(n, v)), 0.001, 1.0);
    float NdotH = clamp(dot(n, h), 0.0, 1.0);
    float LdotH = clamp(dot(l, h), 0.0, 1.0);
    float VdotH = clamp(dot(v, h), 0.0, 1.0);
    float VdotL = clamp(dot(v, l), 0.0, 1.0);

    PBRInfo pbrInputs = PBRInfo(NdotL,
                                NdotV,
                                NdotH,
                                LdotH,
                                VdotH,
                                VdotL,
                                perceptualRoughness,
                                metallic,
                                specularEnvironmentR0,
                                specularEnvironmentR90,
                                alphaRoughness,
                                diffuseColor,
                                specularColor);

    // Calculate the shading terms for the microfacet specular shading model
    vec3 F = specularReflection(pbrInputs);
    float G = geometricOcclusion(pbrInputs);
    float D = microfacetDistribution(pbrInputs);

    const vec3 u_LightColor = vec3(1.0);

    // Calculation of analytical lighting contribution
    vec3 diffuseContrib = (1.0 - F) * BRDF_Diffuse_Disney(pbrInputs);
    vec3 specContrib = F * G * D / (4.0 * NdotL * NdotV);
    // Obtain final intensity as reflectance (BRDF) scaled by the energy of the light (cosine law)
    vec3 color = NdotL * u_LightColor * (diffuseContrib + specContrib);

    color *= ao;

#ifdef VSG_EMISSIVE_MAP
    vec3 emissive = SRGBtoLINEAR(texture(emissiveMap, texCoord0)).rgb * pbr.emissiveFactor.rgb;
#else
    vec3 emissive = pbr.emissiveFactor.rgb;
#endif
    color += emissive;

    return color;
}

float convertMetallic(vec3 diffuse, vec3 specular, float maxSpecular)
{
    float perceivedDiffuse = sqrt(0.299 * diffuse.r * diffuse.r + 0.587 * diffuse.g * diffuse.g + 0.114 * diffuse.b * diffuse.b);
    float perceivedSpecular = sqrt(0.299 * specular.r * specular.r + 0.587 * specular.g * specular.g + 0.114 * specular.b * specular.b);

    if (perceivedSpecular < c_MinRoughness)
    {
        return 0.0;
    }

    float a = c_MinRoughness;
    float b = perceivedDiffuse * (1.0 - maxSpecular) / (1.0 - c_MinRoughness) + perceivedSpecular - 2.0 * c_MinRoughness;
    float c = c_MinRoughness - perceivedSpecular;
    float D = max(b * b - 4.0 * a * c, 0.0);
    return clamp((-b + sqrt(D)) / (2.0 * a), 0.0, 1.0);
}

void main()
{
    float perceptualRoughness = 0.0;
    float metallic;
    vec3 diffuseColor;
    vec4 baseColor;

    float ambientOcclusion = 1.0;

    vec3 f0 = vec3(0.04);

#ifdef VSG_DIFFUSE_MAP
    baseColor = SRGBtoLINEAR(texture(diffuseMap, texCoord0)) * pbr.baseColorFactor;
#else
    baseColor = pbr.baseColorFactor;
#endif

    if (pbr.alphaMask == 1.0f)
    {
        if (baseColor.a < pbr.alphaMaskCutoff)
            discard;
    }


#ifdef VSG_WORKFLOW_SPECGLOSS
    #ifdef VSG_SPECULAR_MAP
        vec3 specular = SRGBtoLINEAR(texture(specularMap, texCoord0)).rgb;
        perceptualRoughness = 1.0 - texture(specularMap, texCoord0).a;
    #else
        vec3 specular = vec3(0.0);
        perceptualRoughness = 0.0;
    #endif

        const float epsilon = 1e-6;

    #ifdef VSG_DIFFUSE_MAP
        vec4 diffuse = SRGBtoLINEAR(texture(diffuseMap, texCoord0));
    #else
        vec4 diffuse = vec4(1.0);
    #endif

        float maxSpecular = max(max(specular.r, specular.g), specular.b);

        // Convert metallic value from specular glossiness inputs
        metallic = convertMetallic(diffuse.rgb, specular, maxSpecular);

        vec3 baseColorDiffusePart = diffuse.rgb * ((1.0 - maxSpecular) / (1 - c_MinRoughness) / max(1 - metallic, epsilon)) * pbr.diffuseFactor.rgb;
        vec3 baseColorSpecularPart = specular - (vec3(c_MinRoughness) * (1 - metallic) * (1 / max(metallic, epsilon))) * pbr.specularFactor.rgb;
        baseColor = vec4(mix(baseColorDiffusePart, baseColorSpecularPart, metallic * metallic), diffuse.a);
#else
        perceptualRoughness = pbr.roughnessFactor;
        metallic = pbr.metallicFactor;

    #ifdef VSG_METALLROUGHNESS_MAP
        vec4 mrSample = texture(mrMap, texCoord0);
        perceptualRoughness = mrSample.g * perceptualRoughness;
        metallic = mrSample.b * metallic;
    #endif
#endif

#ifdef VSG_LIGHTMAP_MAP
    ambientOcclusion = texture(aoMap, texCoord0).r;
#endif

    diffuseColor = baseColor.rgb * (vec3(1.0) - f0);
    diffuseColor *= 1.0 - metallic;

    float alphaRoughness = perceptualRoughness * perceptualRoughness;

    vec3 specularColor = mix(f0, baseColor.rgb, metallic);

    // Compute reflectance.
    float reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);

    // For typical incident reflectance range (between 4% to 100%) set the grazing reflectance to 100% for typical fresnel effect.
    // For very low reflectance range on highly diffuse objects (below 4%), incrementally reduce grazing reflecance to 0%.
    float reflectance90 = clamp(reflectance * 25.0, 0.0, 1.0);
    vec3 specularEnvironmentR0 = specularColor.rgb;
    vec3 specularEnvironmentR90 = vec3(1.0, 1.0, 1.0) * reflectance90;

    vec3 n = getNormal();
    vec3 v = normalize(viewDir);    // Vector from surface point to camera
    vec3 l = normalize(lightDir);     // Vector from surface point to light
    vec3 h = normalize(l+v);                        // Half vector between both l and v

    vec3 colorFrontFace = BRDF(v, n, l, h, perceptualRoughness, metallic, specularEnvironmentR0, specularEnvironmentR90, alphaRoughness, diffuseColor, specularColor, ambientOcclusion);
#ifdef VSG_TWOSIDED
    vec3 colorBackFace = BRDF(v, -n, l, h, perceptualRoughness, metallic, specularEnvironmentR0, specularEnvironmentR90, alphaRoughness, diffuseColor, specularColor, ambientOcclusion);
    vec3 color = colorFrontFace+colorBackFace;
#else
    vec3 color = colorFrontFace;
#endif

    outColor = LINEARtoSRGB(vec4(color, baseColor.a));
}
"
                  SPIRVSize 0
                  SPIRV
                }
                NumSpecializationConstants 0
              }
              NumPipelineStates 6
              PipelineState id=21 vsg::VertexInputState
              {
                NumUserObjects 0
                NumBindings 3
                binding 0
                stride 12
                inputRate 0
                binding 1
                stride 12
                inputRate 0
                binding 2
                stride 8
                inputRate 0
                NumAttributes 3
                location 0
                binding 0
                format 106
                offset 0
                location 1
                binding 1
                format 106
                offset 0
                location 2
                binding 2
                format 103
                offset 0
              }
              PipelineState id=22 vsg::InputAssemblyState
              {
                NumUserObjects 0
                topology 3
                primitiveRestartEnable 0
              }
              PipelineState id=23 vsg::RasterizationState
              {
                NumUserObjects 0
                depthClampEnable 0
                rasterizerDiscardEnable 0
                polygonMode 0
                cullMode 0
                frontFace 0
                depthBiasEnable 0
                depthBiasConstantFactor 1
                depthBiasClamp 0
                depthBiasSlopeFactor 1
                lineWidth 1
              }
              PipelineState id=24 vsg::MultisampleState
              {
                NumUserObjects 0
                rasterizationSamples 1
                sampleShadingEnable 0
                minSampleShading 0
                NumSampleMask 0
                alphaToCoverageEnable 0
                alphaToOneEnable 0
              }
              PipelineState id=25 vsg::ColorBlendState
              {
                NumUserObjects 0
                logicOp 3
                logicOpEnable 0
                NumColorBlendAttachments 1
                blendEnable 0
                srcColorBlendFactor 6
                dstColorBlendFactor 7
                colorBlendOp 0
                srcAlphaBlendFactor 6
                dstAlphaBlendFactor 7
                alphaBlendOp 1
                colorWriteMask 15
                blendConstants 0 0 0 0
              }
              PipelineState id=26 vsg::DepthStencilState
              {
                NumUserObjects 0
                depthTestEnable 1
                depthWriteEnable 1
                depthCompareOp 1
                depthBoundsTestEnable 0
                stencilTestEnable 0
                front.failOp 0
                front.passOp 0
                front.depthFailOp 0
                front.compareOp 0
                front.compareMask 0
                front.writeMask 0
                front.reference 0
                back.failOp 0
                back.passOp 0
                back.depthFailOp 0
                back.compareOp 0
                back.compareMask 0
                back.writeMask 0
                back.reference 0
                minDepthBounds 0
                maxDepthBounds 1
              }
              subpass 0
            }
          }
          StateCommand id=27 vsg::BindDescriptorSet
          {
            NumUserObjects 0
            Slot 1
            PipelineLayout id=15
            firstSet 0
            DescriptorSet id=28 vsg::DescriptorSet
            {
              NumUserObjects 0
              DescriptorSetLayout id=16
              NumDescriptors 1
              Descriptor id=29 vsg::DescriptorBuffer
              {
                NumUserObjects 0
                DstBinding 10
                DstArrayElement 0
                NumData 1
                Data id=30 vsg::ubyteArray
                {
                  NumUserObjects 0
                  Layout 0 1 0 1 1 1 0 -1
                  Size 80
                  Storage id=0
                  Data 0 0 128 63 0 0 128 63 0 0 128 63
                   0 0 128 63 0 0 0 0 0 0 0 0
                   0 0 0 0 0 0 128 63 0 0 128 63
                   0 0 128 63 0 0 128 63 0 0 128 63
                   0 0 0 0 0 0 0 0 0 0 0 0
                   0 0 128 63 0 0 128 63 0 0 128 63
                   0 0 128 63 0 0 0 63
                }
              }
            }
          }
        }
        Matrix 2.98023e-09 -0.025 0 0 0 6.40708e-09 0.107493 0 -0.025 -1.49012e-09 1.49012e-09 0
         0 0 -0.0940672 1
        SubgraphRequiresLocalFrustum 1
      }
      Child id=31 vsg::MatrixTransform
      {
        NumUserObjects 0
        NumChildren 0
        Matrix 0.685921 0 -0.727676 0 0.651558 0.445271 0.61417 0 0.324014 -0.895396 0.305421 0
         7.35889 4.95831 6.92579 1
        SubgraphRequiresLocalFrustum 1
      }
      Matrix 1 0 0 0 0 1 0 0 0 0 1 0
       0 0 0 1
      SubgraphRequiresLocalFrustum 1
    }
    NumStateCommands 2
    StateCommand id=32 vsg::BindGraphicsPipeline
    {
      NumUserObjects 0
      Slot 0
      GraphicsPipeline id=33 vsg::GraphicsPipeline
      {
        NumUserObjects 0
        PipelineLayout id=34 vsg::PipelineLayout
        {
          NumUserObjects 0
          Flags 0
          NumDescriptorSetLayouts 1
          DescriptorSetLayout id=35 vsg::DescriptorSetLayout
          {
            NumUserObjects 0
            NumDescriptorSetLayoutBindings 1
            binding 10
            descriptorType 6
            descriptorCount 1
            stageFlags 16
          }
          NumPushConstantRanges 1
          stageFlags 1
          offset 0
          size 128
        }
        NumShaderStages 2
        ShaderStage id=36 vsg::ShaderStage
        {
          NumUserObjects 0
          Stage 1
          EntryPoint "main"
          ShaderModule id=37 vsg::ShaderModule
          {
            NumUserObjects 0
            Source "#version 450

#extension GL_ARB_separate_shader_objects : enable

layout(push_constant) uniform PushConstants {
    mat4 projection;
    mat4 modelView;
} pc;

layout(location = 0) in vec3 osg_Vertex;
layout(location = 0) out vec3 worldPos;

layout(location = 1) in vec3 osg_Normal;
layout(location = 1) out vec3 normalDir;

layout(location = 2) in vec2 osg_TexCoord0;
layout(location = 2) out vec2 texCoord0;

layout(location = 5) out vec3 viewDir;
layout(location = 6) out vec3 lightDir;

out gl_PerVertex{ vec4 gl_Position; };

void main()
{
    gl_Position = (pc.projection * pc.modelView) * vec4(osg_Vertex, 1.0);
    worldPos = vec4(pc.modelView * vec4(osg_Vertex, 1.0)).xyz;

    vec3 n = (pc.modelView * vec4(osg_Normal, 0.0)).xyz;
    normalDir = n;
    vec4 lpos = /*osg_LightSource.position*/ vec4(0.0, 0.25, 1.0, 0.0);
    viewDir = -vec3(pc.modelView * vec4(osg_Vertex, 1.0));

    if (lpos.w == 0.0)
        lightDir = lpos.xyz;
    else
        lightDir = lpos.xyz + viewDir;

    texCoord0 = osg_TexCoord0 * vec2(1,1);
}
"
            SPIRVSize 0
            SPIRV
          }
          NumSpecializationConstants 0
        }
        ShaderStage id=38 vsg::ShaderStage
        {
          NumUserObjects 0
          Stage 16
          EntryPoint "main"
          ShaderModule id=39 vsg::ShaderModule
          {
            NumUserObjects 0
            Source "#version 450
#pragma import_defines (VSG_DIFFUSE_MAP, VSG_EMISSIVE_MAP, VSG_LIGHTMAP_MAP, VSG_NORMAL_MAP, VSG_SPECULAR_MAP, VSG_TWOSIDED)

#extension GL_ARB_separate_shader_objects : enable

#ifdef VSG_DIFFUSE_MAP
layout(binding = 0) uniform sampler2D diffuseMap;
#endif

#ifdef VSG_NORMAL_MAP
layout(binding = 2) uniform sampler2D normalMap;
#endif

#ifdef VSG_LIGHTMAP_MAP
layout(binding = 3) uniform sampler2D aoMap;
#endif

#ifdef VSG_EMISSIVE_MAP
layout(binding = 4) uniform sampler2D emissiveMap;
#endif

#ifdef VSG_SPECULAR_MAP
layout(binding = 5) uniform sampler2D specularMap;
#endif

layout(push_constant) uniform PushConstants {
    mat4 projection;
    mat4 modelView;
} pc;

layout(binding = 10) uniform MaterialData
{
    vec4 ambientColor;
    vec4 diffuseColor;
    vec4 specularColor;
    vec4 emissiveColor;
    float shininess;
    float alphaMask;
    float alphaMaskCutoff;
} material;

layout(location = 0) in vec3 worldPos;
layout(location = 1) in vec3 normalDir;
layout(location = 2) in vec2 texCoord0;
layout(location = 5) in vec3 viewDir;
layout(location = 6) in vec3 lightDir;

layout(location = 0) out vec4 outColor;

// Find the normal for this fragment, pulling either from a predefined normal map
// or from the interpolated mesh normal and tangent attributes.
vec3 getNormal()
{
#ifdef VSG_NORMAL_MAP
    // Perturb normal, see http://www.thetenthplanet.de/archives/1180
    vec3 tangentNormal = texture(normalMap, texCoord0).xyz * 2.0 - 1.0;

    //tangentNormal *= vec3(2,2,1);

    vec3 q1 = dFdx(worldPos);
    vec3 q2 = dFdy(worldPos);
    vec2 st1 = dFdx(texCoord0);
    vec2 st2 = dFdy(texCoord0);

    vec3 N = normalize(normalDir);
    vec3 T = normalize(q1 * st2.t - q2 * st1.t);
    vec3 B = -normalize(cross(N, T));
    mat3 TBN = mat3(T, B, N);

    return normalize(TBN * tangentNormal);
#else
    return normalize(normalDir);
#endif
}

vec3 computeLighting(vec3 ambientColor, vec3 diffuseColor, vec3 specularColor, vec3 emissiveColor, float shininess, float ambientOcclusion, vec3 ld, vec3 nd, vec3 vd)
{
    vec3 color = vec3(0.0);
    color.rgb += ambientColor;

    float diff = max(dot(ld, nd), 0.0);
    color.rgb += diffuseColor * diff;

    if (diff > 0.0)
    {
        vec3 halfDir = normalize(ld + vd);
        color.rgb += specularColor * pow(max(dot(halfDir, nd), 0.0), shininess);
    }

    vec3 result = color + emissiveColor;
    result *= ambientOcclusion;

    return result;
}

void main()
{
    vec4 ambientColor = material.ambientColor;
    vec4 diffuseColor = material.diffuseColor;
    vec4 specularColor = material.specularColor;
    vec4 emissiveColor = material.emissiveColor;
    float shininess = material.shininess;
    float ambientOcclusion = 1.0;

#ifdef VSG_DIFFUSE_MAP
    diffuseColor *= texture(diffuseMap, texCoord0.st);
#endif

    if (material.alphaMask == 1.0f)
    {
        if (diffuseColor.a < material.alphaMaskCutoff)
            discard;
    }

#ifdef VSG_EMISSIVE_MAP
    emissiveColor *= texture(emissiveMap, texCoord0.st);
#endif

#ifdef VSG_LIGHTMAP_MAP
    ambientOcclusion *= texture(aoMap, texCoord0.st).r;
#endif

#ifdef VSG_SPECULAR_MAP
    specularColor *= texture(specularMap, texCoord0.st);
#endif

    vec3 nd = getNormal();
    vec3 ld = normalize(lightDir);
    vec3 vd = normalize(viewDir);

    vec3 colorFrontFace = computeLighting(ambientColor.rgb, diffuseColor.rgb, specularColor.rgb, emissiveColor.rgb, shininess, ambientOcclusion, ld, nd, vd);
#ifdef VSG_TWOSIDED
    vec3 colorBackFace = computeLighting(ambientColor.rgb, diffuseColor.rgb, specularColor.rgb, emissiveColor.rgb, shininess, ambientOcclusion, ld, -nd, vd);
    outColor.rgb = colorFrontFace + colorBackFace;
#else
    outColor.rgb = colorFrontFace;
#endif
    outColor.a = diffuseColor.a;
}
"
            SPIRVSize 0
            SPIRV
          }
          NumSpecializationConstants 0
        }
        NumPipelineStates 6
        PipelineState id=40 vsg::VertexInputState
        {
          NumUserObjects 0
          NumBindings 3
          binding 0
          stride 12
          inputRate 0
          binding 1
          stride 12
          inputRate 0
          binding 2
          stride 8
          inputRate 0
          NumAttributes 3
          location 0
          binding 0
          format 106
          offset 0
          location 1
          binding 1
          format 106
          offset 0
          location 2
          binding 2
          format 103
          offset 0
        }
        PipelineState id=41 vsg::InputAssemblyState
        {
          NumUserObjects 0
          topology 3
          primitiveRestartEnable 0
        }
        PipelineState id=42 vsg::RasterizationState
        {
          NumUserObjects 0
          depthClampEnable 0
          rasterizerDiscardEnable 0
          polygonMode 0
          cullMode 2
          frontFace 0
          depthBiasEnable 0
          depthBiasConstantFactor 1
          depthBiasClamp 0
          depthBiasSlopeFactor 1
          lineWidth 1
        }
        PipelineState id=43 vsg::MultisampleState
        {
          NumUserObjects 0
          rasterizationSamples 1
          sampleShadingEnable 0
          minSampleShading 0
          NumSampleMask 0
          alphaToCoverageEnable 0
          alphaToOneEnable 0
        }
        PipelineState id=44 vsg::ColorBlendState
        {
          NumUserObjects 0
          logicOp 3
          logicOpEnable 0
          NumColorBlendAttachments 1
          blendEnable 0
          srcColorBlendFactor 6
          dstColorBlendFactor 7
          colorBlendOp 0
          srcAlphaBlendFactor 6
          dstAlphaBlendFactor 7
          alphaBlendOp 1
          colorWriteMask 15
          blendConstants 0 0 0 0
        }
        PipelineState id=45 vsg::DepthStencilState
        {
          NumUserObjects 0
          depthTestEnable 1
          depthWriteEnable 1
          depthCompareOp 1
          depthBoundsTestEnable 0
          stencilTestEnable 0
          front.failOp 0
          front.passOp 0
          front.depthFailOp 0
          front.compareOp 0
          front.compareMask 0
          front.writeMask 0
          front.reference 0
          back.failOp 0
          back.passOp 0
          back.depthFailOp 0
          back.compareOp 0
          back.compareMask 0
          back.writeMask 0
          back.reference 0
          minDepthBounds 0
          maxDepthBounds 1
        }
        subpass 0
      }
    }
    StateCommand id=46 vsg::BindDescriptorSet
    {
      NumUserObjects 0
      Slot 1
      PipelineLayout id=34
      firstSet 0
      DescriptorSet id=47 vsg::DescriptorSet
      {
        NumUserObjects 0
        DescriptorSetLayout id=35
        NumDescriptors 1
        Descriptor id=48 vsg::DescriptorBuffer
        {
          NumUserObjects 0
          DstBinding 10
          DstArrayElement 0
          NumData 1
          Data id=49 vsg::ubyteArray
          {
            NumUserObjects 0
            Layout 0 1 0 1 1 1 0 -1
            Size 76
            Storage id=0
            Data 0 0 0 0 0 0 0 0 0 0 0 0
             0 0 128 63 0 0 128 63 0 0 128 63
             0 0 128 63 0 0 128 63 0 0 0 0
             0 0 0 0 0 0 0 0 0 0 128 63
             0 0 0 0 0 0 0 0 0 0 0 0
             0 0 128 63 0 0 0 0 0 0 128 63
             0 0 0 63
          }
        }
      }
    }
  }
  Matrix 1 0 0 0 0 6.12323e-17 1 0 0 -1 6.12323e-17 0
   0 0 0 1
  SubgraphRequiresLocalFrustum 1
}
